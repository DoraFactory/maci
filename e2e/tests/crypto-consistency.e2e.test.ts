/**
 * Crypto Consistency E2E Test
 *
 * This test validates that cryptographic operations produce identical results
 * across Rust maci-crypto and TypeScript SDK implementations.
 *
 * Test Coverage:
 * - Key generation (deterministic)
 * - ECDH shared key derivation
 * - Message packing/unpacking
 * - Merkle tree operations
 * - Ciphertext rerandomization
 */

import { expect } from 'chai';
import {
  genKeypair,
  genPubKey,
  genEcdhSharedKey,
  packElement,
  unpackElement,
  packPubKey,
  Tree,
  rerandomize,
  SNARK_FIELD_SIZE,
  poseidonT3
} from '@dorafactory/maci-sdk';
import {
  loadCryptoTestVectors,
  vectorsExist,
  findVector,
  filterByType
} from '../crypto-test/load-vectors';
import type { CryptoTestVector } from '../crypto-test/test-vectors';

describe('Crypto Consistency E2E Tests', function () {
  this.timeout(900000); // 15 minutes for comprehensive tests

  let rustTestVectors: CryptoTestVector[] = [];

  before(async function () {
    this.timeout(300000); // 5 minutes for setup

    console.log('Setting up crypto consistency tests...');

    // Load Rust test vectors (REQUIRED)
    if (!vectorsExist()) {
      throw new Error(
        'Crypto test vectors not found. They should be auto-generated by pretest:crypto hook.\n' +
          'If this error occurs, try running: pnpm generate:crypto-vectors'
      );
    }

    rustTestVectors = loadCryptoTestVectors();
    console.log(`✓ Loaded ${rustTestVectors.length} Rust test vectors`);
  });

  describe('1. Keypair Generation Consistency', () => {
    it('should test all keypair vectors', function () {
      const keypairVectors = filterByType(rustTestVectors, 'keypair');

      keypairVectors.forEach((vector) => {
        const data = vector.data;

        // Test deterministic keypair generation
        if (data.seed && data.priv_key && data.pub_key) {
          const seed = BigInt(data.seed);
          const sdkKeypair = genKeypair(seed % SNARK_FIELD_SIZE);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(`    Seed: ${data.seed}`);

          // Compare private key
          const rustPrivKey = BigInt(data.priv_key);
          expect(sdkKeypair.privKey).to.equal(rustPrivKey, 'Private keys should match');
          console.log('    ✓ Private key: MATCH');

          // Compare public key
          const rustPubKeyX = BigInt(data.pub_key.x);
          const rustPubKeyY = BigInt(data.pub_key.y);
          expect(sdkKeypair.pubKey[0]).to.equal(rustPubKeyX, 'Public key X should match');
          expect(sdkKeypair.pubKey[1]).to.equal(rustPubKeyY, 'Public key Y should match');
          console.log('    ✓ Public key: MATCH');

          // Compare formatted private key
          if (data.formatted_priv_key) {
            const rustFormattedPrivKey = BigInt(data.formatted_priv_key);
            expect(sdkKeypair.formatedPrivKey).to.equal(
              rustFormattedPrivKey,
              'Formatted private keys should match'
            );
            console.log('    ✓ Formatted private key: MATCH');
          }

          // Compare packed public key
          if (data.packed_pub_key) {
            const rustPackedPubKey = BigInt(data.packed_pub_key);
            const sdkPackedPubKey = packPubKey(sdkKeypair.pubKey);
            expect(sdkPackedPubKey).to.equal(rustPackedPubKey, 'Packed public keys should match');
            console.log('    ✓ Packed public key: MATCH');
          }
        }

        // Test public key derivation from private key
        if (data.priv_key && data.pub_key && !data.seed) {
          const privKey = BigInt(data.priv_key);
          const sdkPubKey = genPubKey(privKey);

          const rustPubKeyX = BigInt(data.pub_key.x);
          const rustPubKeyY = BigInt(data.pub_key.y);

          expect(sdkPubKey[0]).to.equal(rustPubKeyX, 'Public key X should match');
          expect(sdkPubKey[1]).to.equal(rustPubKeyY, 'Public key Y should match');
          console.log(`\n  ${vector.name}:`);
          console.log('    ✓ Public key derivation: MATCH');
        }
      });
    });

    it('should test keypair with private key 111111 (detailed output)', function () {
      const vector = findVector(rustTestVectors, 'keypair_deterministic_seed_111111');
      const comparisonVector = findVector(rustTestVectors, 'keypair_comparison_seed_111111');

      if (!vector) {
        throw new Error(
          'Test vector "keypair_deterministic_seed_111111" not found. ' +
            'Please ensure Rust test vector generation is working correctly.'
        );
      }

      const data = vector.data;

      // Assert required fields exist - these MUST be generated by Rust
      if (!data.seed || !data.priv_key || !data.pub_key || !data.formatted_priv_key) {
        throw new Error(
          `Test vector ${vector.name} is missing required fields. ` +
            `Found: seed=${!!data.seed}, priv_key=${!!data.priv_key}, pub_key=${!!data.pub_key}, formatted_priv_key=${!!data.formatted_priv_key}. ` +
            'This indicates a problem with Rust test vector generation.'
        );
      }

      const seed = BigInt(data.seed);
      const sdkKeypair = genKeypair(seed % SNARK_FIELD_SIZE);

      console.log('\n  ═══════════════════════════════════════════════════════');
      console.log('  Detailed Test: Private Key = 111111');
      console.log('  ═══════════════════════════════════════════════════════\n');

      console.log('TypeScript SDK Results:');
      console.log(`  Private Key: ${sdkKeypair.privKey}`);
      console.log(`  PubKey X: ${sdkKeypair.pubKey[0]}`);
      console.log(`  PubKey Y: ${sdkKeypair.pubKey[1]}`);
      console.log(`  PubKey X (hex): 0x${sdkKeypair.pubKey[0].toString(16)}`);
      console.log(`  PubKey Y (hex): 0x${sdkKeypair.pubKey[1].toString(16)}`);
      console.log(`  Formatted PrivKey: ${sdkKeypair.formatedPrivKey}`);
      console.log();

      console.log('Rust Implementation Results (keys.rs):');
      console.log(`  Private Key: ${data.priv_key}`);
      console.log(`  PubKey X: ${data.pub_key.x}`);
      console.log(`  PubKey Y: ${data.pub_key.y}`);
      console.log(`  Formatted PrivKey: ${data.formatted_priv_key}`);
      console.log();

      // Add keypair.rs results if comparison vector exists
      if (comparisonVector && comparisonVector.data.keypair) {
        const keypairData = comparisonVector.data.keypair;
        console.log('Rust Implementation Results (keypair.rs):');
        console.log(`  Private Key: ${keypairData.priv_key}`);
        console.log(`  PubKey X: ${keypairData.pub_key.x}`);
        console.log(`  PubKey Y: ${keypairData.pub_key.y}`);
        console.log(`  Formatted PrivKey: ${keypairData.formatted_priv_key}`);
        console.log(`  Commitment: ${keypairData.commitment}`);
        console.log();

        // Generate commitment from SDK for comparison
        const sdkCommitment = poseidonT3([sdkKeypair.pubKey[0], sdkKeypair.pubKey[1]]);
        const rustCommitment = BigInt(keypairData.commitment);
        console.log('Commitment Comparison:');
        console.log(`  TypeScript SDK: 0x${sdkCommitment.toString(16)}`);
        console.log(`  Rust (keypair.rs): ${keypairData.commitment}`);
        console.log(`  Match: ${sdkCommitment === rustCommitment}`);
        console.log();
      }

      // Compare - now TypeScript knows these fields are defined
      const rustPrivKey = BigInt(data.priv_key);
      const rustPubKeyX = BigInt(data.pub_key.x);
      const rustPubKeyY = BigInt(data.pub_key.y);
      const rustFormattedPrivKey = BigInt(data.formatted_priv_key);

      expect(sdkKeypair.privKey).to.equal(rustPrivKey, 'Private keys should match');
      expect(sdkKeypair.pubKey[0]).to.equal(rustPubKeyX, 'Public key X should match');
      expect(sdkKeypair.pubKey[1]).to.equal(rustPubKeyY, 'Public key Y should match');
      expect(sdkKeypair.formatedPrivKey).to.equal(
        rustFormattedPrivKey,
        'Formatted private keys should match'
      );

      console.log('  ✓ All values match between TypeScript SDK and Rust (keys.rs)');
      console.log();
    });
  });

  describe('2. Keypair Comparison (keys vs keypair modules)', () => {
    it('should test all keypair comparison vectors', function () {
      const comparisonVectors = filterByType(rustTestVectors, 'keypair_comparison');

      comparisonVectors.forEach((vector) => {
        const data = vector.data;

        if (data.seed && data.keys_keypair && data.keypair && data.comparison) {
          const seed = BigInt(data.seed);
          const sdkKeypair = genKeypair(seed % SNARK_FIELD_SIZE);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(`    Seed: ${data.seed}`);

          // Test keys::Keypair (current SDK implementation)
          const rustKeysPrivKey = BigInt(data.keys_keypair.priv_key);
          const rustKeysPubKeyX = BigInt(data.keys_keypair.pub_key.x);
          const rustKeysPubKeyY = BigInt(data.keys_keypair.pub_key.y);
          const rustKeysFormattedPrivKey = BigInt(data.keys_keypair.formatted_priv_key);

          expect(sdkKeypair.privKey).to.equal(
            rustKeysPrivKey,
            'keys::Keypair priv_key should match'
          );
          expect(sdkKeypair.pubKey[0]).to.equal(
            rustKeysPubKeyX,
            'keys::Keypair pub_key.x should match'
          );
          expect(sdkKeypair.pubKey[1]).to.equal(
            rustKeysPubKeyY,
            'keys::Keypair pub_key.y should match'
          );
          expect(sdkKeypair.formatedPrivKey).to.equal(
            rustKeysFormattedPrivKey,
            'keys::Keypair formatted_priv_key should match'
          );
          console.log('    ✓ keys::Keypair: MATCH');

          // Test keypair::Keypair implementation
          const rustKeypairPrivKey = BigInt(data.keypair.priv_key);
          const rustKeypairPubKeyX = BigInt(data.keypair.pub_key.x);
          const rustKeypairPubKeyY = BigInt(data.keypair.pub_key.y);
          const rustKeypairFormattedPrivKey = BigInt(data.keypair.formatted_priv_key);
          const rustKeypairCommitment = BigInt(data.keypair.commitment);

          // Verify keypair matches Rust implementation
          expect(rustKeypairPrivKey).to.equal(
            rustKeysPrivKey,
            'keypair priv_key should match keys priv_key'
          );
          expect(rustKeypairPubKeyX).to.equal(
            rustKeysPubKeyX,
            'keypair pub_key.x should match keys pub_key.x'
          );
          expect(rustKeypairPubKeyY).to.equal(
            rustKeysPubKeyY,
            'keypair pub_key.y should match keys pub_key.y'
          );
          console.log('    ✓ keypair::Keypair pub_key: MATCH');

          // Check formatted_priv_key comparison
          const formattedPrivKeyMatch = data.comparison.formatted_priv_key_match;
          if (formattedPrivKeyMatch) {
            expect(rustKeypairFormattedPrivKey).to.equal(
              rustKeysFormattedPrivKey,
              'keypair formatted_priv_key should match keys formatted_priv_key'
            );
            console.log('    ✓ formatted_priv_key: MATCH (both modules)');
          } else {
            console.log('    ⚠ formatted_priv_key: DIFFERENT (expected difference)');
            console.log(
              `      keys::Keypair: ${rustKeysFormattedPrivKey.toString()}\n      keypair::Keypair: ${rustKeypairFormattedPrivKey.toString()}`
            );
          }

          // Generate commitment from SDK and compare
          const sdkCommitment = poseidonT3([sdkKeypair.pubKey[0], sdkKeypair.pubKey[1]]);
          expect(sdkCommitment).to.equal(
            rustKeypairCommitment,
            'SDK commitment should match keypair commitment'
          );
          console.log('    ✓ Commitment: MATCH');

          // Verify comparison results from Rust
          expect(data.comparison.pub_key_match).to.be.true;
          expect(data.comparison.priv_key_match).to.be.true;
          console.log('    ✓ Rust comparison results: VALID');
        }

        // Test byte array input case
        if (data.input_bytes && data.keys_keypair && data.keypair) {
          const inputBytes = Buffer.from(data.input_bytes, 'hex');
          const privKeyFromBytes = BigInt(`0x${data.input_bytes}`);
          const sdkKeypair = genKeypair(privKeyFromBytes % SNARK_FIELD_SIZE);

          const rustKeysPubKeyX = BigInt(data.keys_keypair.pub_key.x);
          const rustKeysPubKeyY = BigInt(data.keys_keypair.pub_key.y);
          const rustKeypairCommitment = BigInt(data.keypair.commitment);

          expect(sdkKeypair.pubKey[0]).to.equal(
            rustKeysPubKeyX,
            'Byte array input: pub_key.x should match'
          );
          expect(sdkKeypair.pubKey[1]).to.equal(
            rustKeysPubKeyY,
            'Byte array input: pub_key.y should match'
          );

          const sdkCommitment = poseidonT3([sdkKeypair.pubKey[0], sdkKeypair.pubKey[1]]);
          expect(sdkCommitment).to.equal(
            rustKeypairCommitment,
            'Byte array input: commitment should match'
          );
          console.log(`\n  ${vector.name}:`);
          console.log('    ✓ Byte array input: MATCH');
        }
      });
    });
  });

  describe('3. ECDH Shared Key Consistency', () => {
    it('should test all ECDH vectors', function () {
      const ecdhVectors = filterByType(rustTestVectors, 'ecdh');

      ecdhVectors.forEach((vector) => {
        const data = vector.data;

        if (data.keypair1 && data.keypair2 && data.shared_key) {
          const privKey1 = BigInt(data.keypair1.priv_key);
          const pubKey2: [bigint, bigint] = [
            BigInt(data.keypair2.pub_key.x),
            BigInt(data.keypair2.pub_key.y)
          ];

          const sdkSharedKey = genEcdhSharedKey(privKey1, pubKey2);

          const rustSharedKeyX = BigInt(data.shared_key.x);
          const rustSharedKeyY = BigInt(data.shared_key.y);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);

          expect(sdkSharedKey[0]).to.equal(rustSharedKeyX, 'Shared key X should match');
          expect(sdkSharedKey[1]).to.equal(rustSharedKeyY, 'Shared key Y should match');
          console.log('    ✓ Shared key: MATCH');

          // Test reciprocal (if available)
          if (data.shared_key_reciprocal) {
            const privKey2 = BigInt(data.keypair2.priv_key);
            const pubKey1: [bigint, bigint] = [
              BigInt(data.keypair1.pub_key.x),
              BigInt(data.keypair1.pub_key.y)
            ];

            const sdkSharedKey2 = genEcdhSharedKey(privKey2, pubKey1);
            const rustSharedKey2X = BigInt(data.shared_key_reciprocal.x);
            const rustSharedKey2Y = BigInt(data.shared_key_reciprocal.y);

            expect(sdkSharedKey2[0]).to.equal(
              rustSharedKey2X,
              'Reciprocal shared key X should match'
            );
            expect(sdkSharedKey2[1]).to.equal(
              rustSharedKey2Y,
              'Reciprocal shared key Y should match'
            );
            console.log('    ✓ Reciprocal shared key: MATCH');

            // Both should be equal (ECDH property)
            expect(sdkSharedKey[0]).to.equal(
              sdkSharedKey2[0],
              'Both parties should derive same shared key X'
            );
            expect(sdkSharedKey[1]).to.equal(
              sdkSharedKey2[1],
              'Both parties should derive same shared key Y'
            );
            console.log('    ✓ ECDH symmetry: MATCH');
          }

          // Test additional methods if available (Keypair struct methods)
          if (data.shared_key_with_public_key) {
            const rustSharedKeyWithPK_X = BigInt(data.shared_key_with_public_key.x);
            const rustSharedKeyWithPK_Y = BigInt(data.shared_key_with_public_key.y);

            // Both methods should produce the same result
            expect(sdkSharedKey[0]).to.equal(
              rustSharedKeyWithPK_X,
              'Keypair.gen_ecdh_shared_key_with_public_key X should match'
            );
            expect(sdkSharedKey[1]).to.equal(
              rustSharedKeyWithPK_Y,
              'Keypair.gen_ecdh_shared_key_with_public_key Y should match'
            );
            console.log('    ✓ Keypair struct method consistency: VERIFIED');
          }

          // Verify consistency check from Rust (if available)
          if (data.consistency_check) {
            if (data.consistency_check.keys_vs_keypair !== undefined) {
              expect(data.consistency_check.keys_vs_keypair).to.be.true;
              console.log('    ✓ Rust keys.rs vs keypair.rs consistency: VERIFIED');
            }
            if (data.consistency_check.method_vs_method !== undefined) {
              expect(data.consistency_check.method_vs_method).to.be.true;
              console.log('    ✓ Rust method vs method consistency: VERIFIED');
            }
          }

          // Verify symmetry check from Rust (if available)
          if (data.symmetry_check !== undefined) {
            expect(data.symmetry_check).to.be.true;
            console.log('    ✓ Rust symmetry check: VERIFIED');
          }
        }
      });
    });

    it('should test ECDH with detailed Alice-Bob scenario (11111, 22222)', function () {
      const vector = findVector(rustTestVectors, 'ecdh_keypair_struct_11111_22222');

      if (!vector) {
        throw new Error(
          'Alice-Bob ECDH test vector (ecdh_keypair_struct_11111_22222) not found. ' +
            'Please ensure Rust test vector generation is working correctly.'
        );
      }

      const data = vector.data;

      // Assert required fields exist - these MUST be generated by Rust
      if (!data.keypair1 || !data.keypair2 || !data.shared_key) {
        throw new Error(
          `Test vector ${vector.name} is missing required fields. ` +
            `Found: keypair1=${!!data.keypair1}, keypair2=${!!data.keypair2}, shared_key=${!!data.shared_key}. ` +
            'This indicates a problem with Rust test vector generation.'
        );
      }

      console.log('\n  ═══════════════════════════════════════════════════════');
      console.log('  Detailed ECDH Test: Alice (11111) ↔ Bob (22222)');
      console.log('  ═══════════════════════════════════════════════════════\n');

      // Alice's keypair
      const alicePrivKey = BigInt(data.keypair1.priv_key);
      const alicePubKey: [bigint, bigint] = [
        BigInt(data.keypair1.pub_key.x),
        BigInt(data.keypair1.pub_key.y)
      ];

      // Bob's keypair
      const bobPrivKey = BigInt(data.keypair2.priv_key);
      const bobPubKey: [bigint, bigint] = [
        BigInt(data.keypair2.pub_key.x),
        BigInt(data.keypair2.pub_key.y)
      ];

      console.log('Alice:');
      console.log(`  Private Key: ${alicePrivKey}`);
      console.log(`  Public Key X: ${alicePubKey[0]}`);
      console.log(`  Public Key Y: ${alicePubKey[1]}`);
      if (data.keypair1.formatted_priv_key) {
        console.log(`  Formatted Private Key: ${BigInt(data.keypair1.formatted_priv_key)}`);
      }

      console.log('\nBob:');
      console.log(`  Private Key: ${bobPrivKey}`);
      console.log(`  Public Key X: ${bobPubKey[0]}`);
      console.log(`  Public Key Y: ${bobPubKey[1]}`);
      if (data.keypair2.formatted_priv_key) {
        console.log(`  Formatted Private Key: ${BigInt(data.keypair2.formatted_priv_key)}`);
      }

      // TypeScript SDK: Alice computes shared key with Bob's public key
      const tsSharedAlice = genEcdhSharedKey(alicePrivKey, bobPubKey);
      console.log('\nTypeScript SDK - Alice computes shared key:');
      console.log(`  Shared Key X: ${tsSharedAlice[0]}`);
      console.log(`  Shared Key Y: ${tsSharedAlice[1]}`);

      // TypeScript SDK: Bob computes shared key with Alice's public key
      const tsSharedBob = genEcdhSharedKey(bobPrivKey, alicePubKey);
      console.log('\nTypeScript SDK - Bob computes shared key:');
      console.log(`  Shared Key X: ${tsSharedBob[0]}`);
      console.log(`  Shared Key Y: ${tsSharedBob[1]}`);

      // Rust results
      const rustSharedKey = [BigInt(data.shared_key.x), BigInt(data.shared_key.y)];
      console.log('\nRust (Keypair struct) - Shared key:');
      console.log(`  Shared Key X: ${rustSharedKey[0]}`);
      console.log(`  Shared Key Y: ${rustSharedKey[1]}`);

      // Verify all match
      console.log('\n─────────────────────────────────────────────────────');
      console.log('Verification:');

      // TypeScript symmetry
      expect(tsSharedAlice[0]).to.equal(tsSharedBob[0], 'TS: Alice and Bob X should match');
      expect(tsSharedAlice[1]).to.equal(tsSharedBob[1], 'TS: Alice and Bob Y should match');
      console.log('  ✓ TypeScript ECDH symmetry: VERIFIED');

      // TypeScript vs Rust
      expect(tsSharedAlice[0]).to.equal(rustSharedKey[0], 'TS vs Rust: X should match');
      expect(tsSharedAlice[1]).to.equal(rustSharedKey[1], 'TS vs Rust: Y should match');
      console.log('  ✓ TypeScript ↔ Rust consistency: VERIFIED');

      // Rust symmetry check
      if (data.symmetry_check !== undefined) {
        expect(data.symmetry_check).to.be.true;
        console.log('  ✓ Rust ECDH symmetry: VERIFIED');
      }

      console.log('  ═══════════════════════════════════════════════════════\n');
    });
  });

  describe('4. Message Packing/Unpacking Consistency', () => {
    it('should test all pack vectors', function () {
      const packVectors = filterByType(rustTestVectors, 'pack');

      packVectors.forEach((vector) => {
        const data = vector.data;

        if (data.input && data.packed && data.unpacked) {
          // Use BigInt directly to avoid precision loss with Number()
          // packElement accepts number | bigint and converts internally
          const nonce = BigInt(data.input.nonce);
          const stateIdx = BigInt(data.input.state_idx);
          const voIdx = BigInt(data.input.vo_idx);
          const newVotes = BigInt(data.input.new_votes);
          const salt = data.input.salt ? BigInt(data.input.salt) : undefined;

          const sdkPacked = packElement({ nonce, stateIdx, voIdx, newVotes, salt });
          const rustPacked = BigInt(data.packed);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(
            `    Input: nonce=${nonce}, stateIdx=${stateIdx}, voIdx=${voIdx}, newVotes=${newVotes}`
          );

          expect(sdkPacked).to.equal(rustPacked, 'Packed values should match');
          console.log('    ✓ Packing: MATCH');

          // Test unpacking
          const sdkUnpacked = unpackElement(sdkPacked);
          const rustUnpacked = {
            nonce: BigInt(data.unpacked.nonce),
            stateIdx: BigInt(data.unpacked.state_idx),
            voIdx: BigInt(data.unpacked.vo_idx),
            newVotes: BigInt(data.unpacked.new_votes)
          };

          expect(sdkUnpacked.nonce).to.equal(rustUnpacked.nonce, 'Unpacked nonce should match');
          expect(sdkUnpacked.stateIdx).to.equal(
            rustUnpacked.stateIdx,
            'Unpacked stateIdx should match'
          );
          expect(sdkUnpacked.voIdx).to.equal(rustUnpacked.voIdx, 'Unpacked voIdx should match');
          expect(sdkUnpacked.newVotes).to.equal(
            rustUnpacked.newVotes,
            'Unpacked newVotes should match'
          );
          console.log('    ✓ Unpacking: MATCH');
        }
      });
    });
  });

  describe('5. Merkle Tree Consistency', () => {
    it('should test all tree vectors', function () {
      const treeVectors = filterByType(rustTestVectors, 'tree');

      treeVectors.forEach((vector) => {
        const data = vector.data;

        if (data.degree && data.depth && data.zero && data.leaves && data.root) {
          const degree = data.degree;
          const depth = data.depth;
          const zero = BigInt(data.zero);
          const leaves = data.leaves.map((leaf: string) => BigInt(leaf));
          const rustRoot = BigInt(data.root);

          const sdkTree = new Tree(degree, depth, zero);
          sdkTree.initLeaves(leaves);
          const sdkRoot = sdkTree.root;

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(`    Tree: ${degree}-ary, depth=${depth}, ${leaves.length} leaves`);

          expect(sdkRoot).to.equal(rustRoot, 'Tree roots should match');
          console.log('    ✓ Tree root: MATCH');

          // Verify leaves
          for (let i = 0; i < leaves.length; i++) {
            const sdkLeaf = sdkTree.leaf(i);
            expect(sdkLeaf).to.equal(leaves[i], `Leaf ${i} should match`);
          }
          console.log('    ✓ Leaves: MATCH');
        }
      });
    });
  });

  describe('6. Ciphertext Rerandomization Consistency', () => {
    it('should test all rerandomize vectors', function () {
      const rerandomizeVectors = filterByType(rustTestVectors, 'rerandomize');

      rerandomizeVectors.forEach((vector) => {
        const data = vector.data;

        if (data.pub_key && data.ciphertext && data.random_val && data.rerandomized) {
          const pubKey: [bigint, bigint] = [BigInt(data.pub_key.x), BigInt(data.pub_key.y)];
          const ciphertext = {
            c1: [BigInt(data.ciphertext.c1.x), BigInt(data.ciphertext.c1.y)],
            c2: [BigInt(data.ciphertext.c2.x), BigInt(data.ciphertext.c2.y)]
          };
          const randomVal = BigInt(data.random_val);

          const sdkRerandomized = rerandomize(pubKey, ciphertext, randomVal);

          // Note: TypeScript SDK returns {d1, d2} but Rust outputs {c1, c2}
          // They represent the same thing (rerandomized ciphertext components)
          const rustC1X = BigInt(data.rerandomized.c1.x);
          const rustC1Y = BigInt(data.rerandomized.c1.y);
          const rustC2X = BigInt(data.rerandomized.c2.x);
          const rustC2Y = BigInt(data.rerandomized.c2.y);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);

          expect(sdkRerandomized.d1[0]).to.equal(rustC1X, 'Rerandomized d1.x (c1.x) should match');
          expect(sdkRerandomized.d1[1]).to.equal(rustC1Y, 'Rerandomized d1.y (c1.y) should match');
          expect(sdkRerandomized.d2[0]).to.equal(rustC2X, 'Rerandomized d2.x (c2.x) should match');
          expect(sdkRerandomized.d2[1]).to.equal(rustC2Y, 'Rerandomized d2.y (c2.y) should match');
          console.log('    ✓ Rerandomization: MATCH');
        }
      });
    });
  });

  after(function () {
    console.log('\n═══════════════════════════════════════════════════════');
    console.log('Crypto Consistency Test Complete');
    console.log(`Total test vectors: ${rustTestVectors.length}`);
    console.log('═══════════════════════════════════════════════════════\n');
  });
});
