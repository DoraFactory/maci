/**
 * Crypto Consistency E2E Test
 *
 * This test validates that cryptographic operations produce identical results
 * across Rust maci-crypto and TypeScript SDK implementations.
 *
 * Test Coverage:
 * - Key generation (deterministic)
 * - ECDH shared key derivation
 * - Message packing/unpacking
 * - Merkle tree operations
 * - Ciphertext rerandomization
 */

import { expect } from 'chai';
import {
  genKeypair,
  genPubKey,
  genEcdhSharedKey,
  packElement,
  unpackElement,
  packPubKey,
  Tree,
  rerandomize,
  SNARK_FIELD_SIZE,
  poseidonT3
} from '@dorafactory/maci-sdk';
import {
  loadCryptoTestVectors,
  vectorsExist,
  findVector,
  filterByType
} from '../crypto-test/load-vectors';
import type { CryptoTestVector } from '../crypto-test/test-vectors';

describe.skip('Crypto Consistency E2E Tests', function () {
  this.timeout(900000); // 15 minutes for comprehensive tests

  let rustTestVectors: CryptoTestVector[] = [];

  before(async function () {
    this.timeout(300000); // 5 minutes for setup

    console.log('Setting up crypto consistency tests...');

    // Load Rust test vectors (REQUIRED)
    if (!vectorsExist()) {
      throw new Error(
        'Crypto test vectors not found. They should be auto-generated by pretest:crypto hook.\n' +
          'If this error occurs, try running: pnpm generate:crypto-vectors'
      );
    }

    rustTestVectors = loadCryptoTestVectors();
    console.log(`✓ Loaded ${rustTestVectors.length} Rust test vectors`);
  });

  describe('1. Keypair Generation Consistency', () => {
    it('should test all keypair vectors', function () {
      const keypairVectors = filterByType(rustTestVectors, 'keypair');

      keypairVectors.forEach((vector) => {
        const data = vector.data;

        // Test deterministic keypair generation
        if (data.seed && data.priv_key && data.pub_key) {
          const seed = BigInt(data.seed);
          const sdkKeypair = genKeypair(seed % SNARK_FIELD_SIZE);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(`    Seed: ${data.seed}`);

          // Compare private key
          const rustPrivKey = BigInt(data.priv_key);
          expect(sdkKeypair.privKey).to.equal(rustPrivKey, 'Private keys should match');
          console.log('    ✓ Private key: MATCH');

          // Compare public key
          const rustPubKeyX = BigInt(data.pub_key.x);
          const rustPubKeyY = BigInt(data.pub_key.y);
          expect(sdkKeypair.pubKey[0]).to.equal(rustPubKeyX, 'Public key X should match');
          expect(sdkKeypair.pubKey[1]).to.equal(rustPubKeyY, 'Public key Y should match');
          console.log('    ✓ Public key: MATCH');

          // Compare formatted private key
          if (data.formatted_priv_key) {
            const rustFormattedPrivKey = BigInt(data.formatted_priv_key);
            expect(sdkKeypair.formatedPrivKey).to.equal(
              rustFormattedPrivKey,
              'Formatted private keys should match'
            );
            console.log('    ✓ Formatted private key: MATCH');
          }

          // Compare packed public key
          if (data.packed_pub_key) {
            const rustPackedPubKey = BigInt(data.packed_pub_key);
            const sdkPackedPubKey = packPubKey(sdkKeypair.pubKey);
            expect(sdkPackedPubKey).to.equal(rustPackedPubKey, 'Packed public keys should match');
            console.log('    ✓ Packed public key: MATCH');
          }
        }

        // Test public key derivation from private key
        if (data.priv_key && data.pub_key && !data.seed) {
          const privKey = BigInt(data.priv_key);
          const sdkPubKey = genPubKey(privKey);

          const rustPubKeyX = BigInt(data.pub_key.x);
          const rustPubKeyY = BigInt(data.pub_key.y);

          expect(sdkPubKey[0]).to.equal(rustPubKeyX, 'Public key X should match');
          expect(sdkPubKey[1]).to.equal(rustPubKeyY, 'Public key Y should match');
          console.log(`\n  ${vector.name}:`);
          console.log('    ✓ Public key derivation: MATCH');
        }
      });
    });

    it('should test keypair with private key 111111 (detailed output)', function () {
      const vector = findVector(rustTestVectors, 'keypair_deterministic_seed_111111');
      const comparisonVector = findVector(rustTestVectors, 'keypair_comparison_seed_111111');

      if (!vector) {
        console.log('  ⚠️  Test vector for seed 111111 not found, skipping detailed test');
        return;
      }

      const data = vector.data;

      // Type guard: ensure required fields exist
      if (!data.seed || !data.priv_key || !data.pub_key || !data.formatted_priv_key) {
        console.log('  ⚠️  Test vector missing required fields, skipping detailed test');
        return;
      }

      const seed = BigInt(data.seed);
      const sdkKeypair = genKeypair(seed % SNARK_FIELD_SIZE);

      console.log('\n  ═══════════════════════════════════════════════════════');
      console.log('  Detailed Test: Private Key = 111111');
      console.log('  ═══════════════════════════════════════════════════════\n');

      console.log('TypeScript SDK Results:');
      console.log(`  Private Key: ${sdkKeypair.privKey}`);
      console.log(`  PubKey X: ${sdkKeypair.pubKey[0]}`);
      console.log(`  PubKey Y: ${sdkKeypair.pubKey[1]}`);
      console.log(`  PubKey X (hex): 0x${sdkKeypair.pubKey[0].toString(16)}`);
      console.log(`  PubKey Y (hex): 0x${sdkKeypair.pubKey[1].toString(16)}`);
      console.log(`  Formatted PrivKey: ${sdkKeypair.formatedPrivKey}`);
      console.log();

      console.log('Rust Implementation Results (keys.rs):');
      console.log(`  Private Key: ${data.priv_key}`);
      console.log(`  PubKey X: ${data.pub_key.x}`);
      console.log(`  PubKey Y: ${data.pub_key.y}`);
      console.log(`  Formatted PrivKey: ${data.formatted_priv_key}`);
      console.log();

      // Add keypair.rs results if comparison vector exists
      if (comparisonVector && comparisonVector.data.keypair) {
        const keypairData = comparisonVector.data.keypair;
        console.log('Rust Implementation Results (keypair.rs):');
        console.log(`  Private Key: ${keypairData.priv_key}`);
        console.log(`  PubKey X: ${keypairData.pub_key.x}`);
        console.log(`  PubKey Y: ${keypairData.pub_key.y}`);
        console.log(`  Formatted PrivKey: ${keypairData.formatted_priv_key}`);
        console.log(`  Commitment: ${keypairData.commitment}`);
        console.log();

        // Generate commitment from SDK for comparison
        const sdkCommitment = poseidonT3([sdkKeypair.pubKey[0], sdkKeypair.pubKey[1]]);
        const rustCommitment = BigInt(keypairData.commitment);
        console.log('Commitment Comparison:');
        console.log(`  TypeScript SDK: 0x${sdkCommitment.toString(16)}`);
        console.log(`  Rust (keypair.rs): ${keypairData.commitment}`);
        console.log(`  Match: ${sdkCommitment === rustCommitment}`);
        console.log();
      }

      // Compare - now TypeScript knows these fields are defined
      const rustPrivKey = BigInt(data.priv_key);
      const rustPubKeyX = BigInt(data.pub_key.x);
      const rustPubKeyY = BigInt(data.pub_key.y);
      const rustFormattedPrivKey = BigInt(data.formatted_priv_key);

      expect(sdkKeypair.privKey).to.equal(rustPrivKey, 'Private keys should match');
      expect(sdkKeypair.pubKey[0]).to.equal(rustPubKeyX, 'Public key X should match');
      expect(sdkKeypair.pubKey[1]).to.equal(rustPubKeyY, 'Public key Y should match');
      expect(sdkKeypair.formatedPrivKey).to.equal(
        rustFormattedPrivKey,
        'Formatted private keys should match'
      );

      console.log('  ✓ All values match between TypeScript SDK and Rust (keys.rs)');
      console.log();
    });
  });

  describe('2. Keypair Comparison (keys vs keypair modules)', () => {
    it('should test all keypair comparison vectors', function () {
      const comparisonVectors = filterByType(rustTestVectors, 'keypair_comparison');

      comparisonVectors.forEach((vector) => {
        const data = vector.data;

        if (data.seed && data.keys_keypair && data.keypair && data.comparison) {
          const seed = BigInt(data.seed);
          const sdkKeypair = genKeypair(seed % SNARK_FIELD_SIZE);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(`    Seed: ${data.seed}`);

          // Test keys::Keypair (current SDK implementation)
          const rustKeysPrivKey = BigInt(data.keys_keypair.priv_key);
          const rustKeysPubKeyX = BigInt(data.keys_keypair.pub_key.x);
          const rustKeysPubKeyY = BigInt(data.keys_keypair.pub_key.y);
          const rustKeysFormattedPrivKey = BigInt(data.keys_keypair.formatted_priv_key);

          expect(sdkKeypair.privKey).to.equal(
            rustKeysPrivKey,
            'keys::Keypair priv_key should match'
          );
          expect(sdkKeypair.pubKey[0]).to.equal(
            rustKeysPubKeyX,
            'keys::Keypair pub_key.x should match'
          );
          expect(sdkKeypair.pubKey[1]).to.equal(
            rustKeysPubKeyY,
            'keys::Keypair pub_key.y should match'
          );
          expect(sdkKeypair.formatedPrivKey).to.equal(
            rustKeysFormattedPrivKey,
            'keys::Keypair formatted_priv_key should match'
          );
          console.log('    ✓ keys::Keypair: MATCH');

          // Test keypair::Keypair implementation
          const rustKeypairPrivKey = BigInt(data.keypair.priv_key);
          const rustKeypairPubKeyX = BigInt(data.keypair.pub_key.x);
          const rustKeypairPubKeyY = BigInt(data.keypair.pub_key.y);
          const rustKeypairFormattedPrivKey = BigInt(data.keypair.formatted_priv_key);
          const rustKeypairCommitment = BigInt(data.keypair.commitment);

          // Verify keypair matches Rust implementation
          expect(rustKeypairPrivKey).to.equal(
            rustKeysPrivKey,
            'keypair priv_key should match keys priv_key'
          );
          expect(rustKeypairPubKeyX).to.equal(
            rustKeysPubKeyX,
            'keypair pub_key.x should match keys pub_key.x'
          );
          expect(rustKeypairPubKeyY).to.equal(
            rustKeysPubKeyY,
            'keypair pub_key.y should match keys pub_key.y'
          );
          console.log('    ✓ keypair::Keypair pub_key: MATCH');

          // Check formatted_priv_key comparison
          const formattedPrivKeyMatch = data.comparison.formatted_priv_key_match;
          if (formattedPrivKeyMatch) {
            expect(rustKeypairFormattedPrivKey).to.equal(
              rustKeysFormattedPrivKey,
              'keypair formatted_priv_key should match keys formatted_priv_key'
            );
            console.log('    ✓ formatted_priv_key: MATCH (both modules)');
          } else {
            console.log('    ⚠ formatted_priv_key: DIFFERENT (expected difference)');
            console.log(
              `      keys::Keypair: ${rustKeysFormattedPrivKey.toString()}\n      keypair::Keypair: ${rustKeypairFormattedPrivKey.toString()}`
            );
          }

          // Generate commitment from SDK and compare
          const sdkCommitment = poseidonT3([sdkKeypair.pubKey[0], sdkKeypair.pubKey[1]]);
          expect(sdkCommitment).to.equal(
            rustKeypairCommitment,
            'SDK commitment should match keypair commitment'
          );
          console.log('    ✓ Commitment: MATCH');

          // Verify comparison results from Rust
          expect(data.comparison.pub_key_match).to.be.true;
          expect(data.comparison.priv_key_match).to.be.true;
          console.log('    ✓ Rust comparison results: VALID');
        }

        // Test byte array input case
        if (data.input_bytes && data.keys_keypair && data.keypair) {
          const inputBytes = Buffer.from(data.input_bytes, 'hex');
          const privKeyFromBytes = BigInt(`0x${data.input_bytes}`);
          const sdkKeypair = genKeypair(privKeyFromBytes % SNARK_FIELD_SIZE);

          const rustKeysPubKeyX = BigInt(data.keys_keypair.pub_key.x);
          const rustKeysPubKeyY = BigInt(data.keys_keypair.pub_key.y);
          const rustKeypairCommitment = BigInt(data.keypair.commitment);

          expect(sdkKeypair.pubKey[0]).to.equal(
            rustKeysPubKeyX,
            'Byte array input: pub_key.x should match'
          );
          expect(sdkKeypair.pubKey[1]).to.equal(
            rustKeysPubKeyY,
            'Byte array input: pub_key.y should match'
          );

          const sdkCommitment = poseidonT3([sdkKeypair.pubKey[0], sdkKeypair.pubKey[1]]);
          expect(sdkCommitment).to.equal(
            rustKeypairCommitment,
            'Byte array input: commitment should match'
          );
          console.log(`\n  ${vector.name}:`);
          console.log('    ✓ Byte array input: MATCH');
        }
      });
    });
  });

  describe('3. ECDH Shared Key Consistency', () => {
    it('should test all ECDH vectors', function () {
      const ecdhVectors = filterByType(rustTestVectors, 'ecdh');

      ecdhVectors.forEach((vector) => {
        const data = vector.data;

        if (data.keypair1 && data.keypair2 && data.shared_key) {
          const privKey1 = BigInt(data.keypair1.priv_key);
          const pubKey2: [bigint, bigint] = [
            BigInt(data.keypair2.pub_key.x),
            BigInt(data.keypair2.pub_key.y)
          ];

          const sdkSharedKey = genEcdhSharedKey(privKey1, pubKey2);

          const rustSharedKeyX = BigInt(data.shared_key.x);
          const rustSharedKeyY = BigInt(data.shared_key.y);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);

          expect(sdkSharedKey[0]).to.equal(rustSharedKeyX, 'Shared key X should match');
          expect(sdkSharedKey[1]).to.equal(rustSharedKeyY, 'Shared key Y should match');
          console.log('    ✓ Shared key: MATCH');

          // Test reciprocal (if available)
          if (data.shared_key_reciprocal) {
            const privKey2 = BigInt(data.keypair2.priv_key);
            const pubKey1: [bigint, bigint] = [
              BigInt(data.keypair1.pub_key.x),
              BigInt(data.keypair1.pub_key.y)
            ];

            const sdkSharedKey2 = genEcdhSharedKey(privKey2, pubKey1);
            const rustSharedKey2X = BigInt(data.shared_key_reciprocal.x);
            const rustSharedKey2Y = BigInt(data.shared_key_reciprocal.y);

            expect(sdkSharedKey2[0]).to.equal(
              rustSharedKey2X,
              'Reciprocal shared key X should match'
            );
            expect(sdkSharedKey2[1]).to.equal(
              rustSharedKey2Y,
              'Reciprocal shared key Y should match'
            );
            console.log('    ✓ Reciprocal shared key: MATCH');

            // Both should be equal (ECDH property)
            expect(sdkSharedKey[0]).to.equal(
              sdkSharedKey2[0],
              'Both parties should derive same shared key X'
            );
            expect(sdkSharedKey[1]).to.equal(
              sdkSharedKey2[1],
              'Both parties should derive same shared key Y'
            );
            console.log('    ✓ ECDH symmetry: MATCH');
          }
        }
      });
    });
  });

  describe('4. Message Packing/Unpacking Consistency', () => {
    it('should test all pack vectors', function () {
      const packVectors = filterByType(rustTestVectors, 'pack');

      packVectors.forEach((vector) => {
        const data = vector.data;

        if (data.input && data.packed && data.unpacked) {
          // Use BigInt directly to avoid precision loss with Number()
          // packElement accepts number | bigint and converts internally
          const nonce = BigInt(data.input.nonce);
          const stateIdx = BigInt(data.input.state_idx);
          const voIdx = BigInt(data.input.vo_idx);
          const newVotes = BigInt(data.input.new_votes);
          const salt = data.input.salt ? BigInt(data.input.salt) : undefined;

          const sdkPacked = packElement({ nonce, stateIdx, voIdx, newVotes, salt });
          const rustPacked = BigInt(data.packed);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(
            `    Input: nonce=${nonce}, stateIdx=${stateIdx}, voIdx=${voIdx}, newVotes=${newVotes}`
          );

          expect(sdkPacked).to.equal(rustPacked, 'Packed values should match');
          console.log('    ✓ Packing: MATCH');

          // Test unpacking
          const sdkUnpacked = unpackElement(sdkPacked);
          const rustUnpacked = {
            nonce: BigInt(data.unpacked.nonce),
            stateIdx: BigInt(data.unpacked.state_idx),
            voIdx: BigInt(data.unpacked.vo_idx),
            newVotes: BigInt(data.unpacked.new_votes)
          };

          expect(sdkUnpacked.nonce).to.equal(rustUnpacked.nonce, 'Unpacked nonce should match');
          expect(sdkUnpacked.stateIdx).to.equal(
            rustUnpacked.stateIdx,
            'Unpacked stateIdx should match'
          );
          expect(sdkUnpacked.voIdx).to.equal(rustUnpacked.voIdx, 'Unpacked voIdx should match');
          expect(sdkUnpacked.newVotes).to.equal(
            rustUnpacked.newVotes,
            'Unpacked newVotes should match'
          );
          console.log('    ✓ Unpacking: MATCH');
        }
      });
    });
  });

  describe('5. Merkle Tree Consistency', () => {
    it('should test all tree vectors', function () {
      const treeVectors = filterByType(rustTestVectors, 'tree');

      treeVectors.forEach((vector) => {
        const data = vector.data;

        if (data.degree && data.depth && data.zero && data.leaves && data.root) {
          const degree = data.degree;
          const depth = data.depth;
          const zero = BigInt(data.zero);
          const leaves = data.leaves.map((leaf: string) => BigInt(leaf));
          const rustRoot = BigInt(data.root);

          const sdkTree = new Tree(degree, depth, zero);
          sdkTree.initLeaves(leaves);
          const sdkRoot = sdkTree.root;

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);
          console.log(`    Tree: ${degree}-ary, depth=${depth}, ${leaves.length} leaves`);

          expect(sdkRoot).to.equal(rustRoot, 'Tree roots should match');
          console.log('    ✓ Tree root: MATCH');

          // Verify leaves
          for (let i = 0; i < leaves.length; i++) {
            const sdkLeaf = sdkTree.leaf(i);
            expect(sdkLeaf).to.equal(leaves[i], `Leaf ${i} should match`);
          }
          console.log('    ✓ Leaves: MATCH');
        }
      });
    });
  });

  describe('6. Ciphertext Rerandomization Consistency', () => {
    it('should test all rerandomize vectors', function () {
      const rerandomizeVectors = filterByType(rustTestVectors, 'rerandomize');

      rerandomizeVectors.forEach((vector) => {
        const data = vector.data;

        if (data.pub_key && data.ciphertext && data.random_val && data.rerandomized) {
          const pubKey: [bigint, bigint] = [BigInt(data.pub_key.x), BigInt(data.pub_key.y)];
          const ciphertext = {
            c1: [BigInt(data.ciphertext.c1.x), BigInt(data.ciphertext.c1.y)],
            c2: [BigInt(data.ciphertext.c2.x), BigInt(data.ciphertext.c2.y)]
          };
          const randomVal = BigInt(data.random_val);

          const sdkRerandomized = rerandomize(pubKey, ciphertext, randomVal);

          const rustD1X = BigInt(data.rerandomized.d1.x);
          const rustD1Y = BigInt(data.rerandomized.d1.y);
          const rustD2X = BigInt(data.rerandomized.d2.x);
          const rustD2Y = BigInt(data.rerandomized.d2.y);

          console.log(`\n  ${vector.name}:`);
          console.log(`    Description: ${vector.description}`);

          expect(sdkRerandomized.d1[0]).to.equal(rustD1X, 'Rerandomized d1.x should match');
          expect(sdkRerandomized.d1[1]).to.equal(rustD1Y, 'Rerandomized d1.y should match');
          expect(sdkRerandomized.d2[0]).to.equal(rustD2X, 'Rerandomized d2.x should match');
          expect(sdkRerandomized.d2[1]).to.equal(rustD2Y, 'Rerandomized d2.y should match');
          console.log('    ✓ Rerandomization: MATCH');
        }
      });
    });
  });

  after(function () {
    console.log('\n═══════════════════════════════════════════════════════');
    console.log('Crypto Consistency Test Complete');
    console.log(`Total test vectors: ${rustTestVectors.length}`);
    console.log('═══════════════════════════════════════════════════════\n');
  });
});
