/**
 * Deactivate Root E2E Test
 *
 * This test validates that the `genDeactivateRoot` operation produces identical results
 * across Rust maci-crypto and TypeScript SDK implementations.
 *
 * Test Coverage:
 * 1. genDeactivateRoot with multiple accounts - consistency check
 * 2. genDeactivateRoot with single account - edge case
 * 3. Different state tree depths - parameter validation
 * 4. Deactivate entries structure validation
 * 5. Merkle tree root consistency
 *
 * Based on AMACI deactivate flow:
 * - Coordinator generates deactivate root for a set of accounts
 * - Each account gets a deactivate entry: [c1.x, c1.y, c2.x, c2.y, shared_key_hash]
 * - All entries are hashed and organized into a Merkle tree
 * - Tree root is used for AMACI circuit verification
 */

import { expect } from 'chai';
import { EdDSAPoseidonKeypair, Tree, poseidon, PubKey } from '@dorafactory/maci-sdk';
import { loadCryptoTestVectors, vectorsExist, filterByType } from '../crypto-test/load-vectors';
import type { CryptoTestVector } from '../crypto-test/test-vectors';

describe('Deactivate Root E2E Tests', function () {
  this.timeout(900000); // 15 minutes for comprehensive tests

  let rustTestVectors: CryptoTestVector[] = [];

  before(async function () {
    this.timeout(300000); // 5 minutes for setup

    console.log('Setting up deactivate root tests...');

    // Load Rust test vectors (REQUIRED)
    if (!vectorsExist()) {
      throw new Error(
        'Crypto test vectors not found. They should be auto-generated by pretest:crypto hook.\n' +
          'If this error occurs, try running: pnpm generate:crypto-vectors'
      );
    }

    rustTestVectors = loadCryptoTestVectors();
    console.log(`✓ Loaded ${rustTestVectors.length} Rust test vectors`);
  });

  describe('1. genDeactivateRoot with Multiple Accounts', () => {
    it('should test all deactivate root vectors with multiple accounts', function () {
      const deactivateVectors = filterByType(rustTestVectors, 'amaci_deactivate_root').filter(
        (v) => !v.name.includes('single_account')
      );

      console.log(`\n  Testing ${deactivateVectors.length} deactivate root vectors...\n`);

      deactivateVectors.forEach((vector) => {
        const data = vector.data;

        // Validate required fields - fail fast if data is missing
        if (
          !data.coordinator_seed ||
          !data.coordinator_pub_key ||
          !data.accounts ||
          data.state_tree_depth === undefined ||
          !data.deactivates ||
          !data.leaves ||
          !data.root ||
          data.tree_depth === undefined ||
          data.tree_degree === undefined
        ) {
          throw new Error(
            `Missing required data in test vector "${vector.name}". ` +
              `All deactivate root vectors must have: coordinator_seed, coordinator_pub_key, ` +
              `accounts, state_tree_depth, deactivates, leaves, root, tree_depth, tree_degree`
          );
        }

        console.log(`\n  ${vector.name}:`);
        console.log(`    Description: ${vector.description}`);
        console.log(`    Coordinator seed: ${data.coordinator_seed}`);
        console.log(`    State tree depth: ${data.state_tree_depth}`);
        console.log(`    Number of accounts: ${data.accounts.length}`);
        console.log(`    Tree depth: ${data.tree_depth}`);
        console.log(`    Tree degree: ${data.tree_degree}`);

        // Create coordinator keypair
        const coordinatorSeed = BigInt(data.coordinator_seed);
        const coordinator = EdDSAPoseidonKeypair.fromSecretKey(coordinatorSeed);

        const coordinatorPubKey = coordinator.getPublicKey().toPoints();
        console.log(`    Coordinator pubkey: [${coordinatorPubKey[0]}, ${coordinatorPubKey[1]}]`);

        // Verify coordinator public key matches
        const rustCoordinatorPubKey = [
          BigInt(data.coordinator_pub_key.x),
          BigInt(data.coordinator_pub_key.y)
        ];
        expect(coordinatorPubKey[0]).to.equal(
          rustCoordinatorPubKey[0],
          'Coordinator pubkey X should match'
        );
        expect(coordinatorPubKey[1]).to.equal(
          rustCoordinatorPubKey[1],
          'Coordinator pubkey Y should match'
        );
        console.log('    ✓ Coordinator keypair verified');

        // Parse accounts
        const accounts: PubKey[] = data.accounts.map((account: any) => [
          BigInt(account.x),
          BigInt(account.y)
        ]);

        console.log(`\n    Accounts:`);
        accounts.forEach((account, idx) => {
          console.log(`      ${idx}: [${account[0]}, ${account[1]}]`);
        });

        // Generate deactivate root using TypeScript SDK
        const tsResult = coordinator.genDeactivateRoot(accounts, Number(data.state_tree_depth));

        console.log(`\n    TypeScript Results:`);
        console.log(`      Number of deactivates: ${tsResult.deactivates.length}`);
        console.log(`      Number of leaves: ${tsResult.leaves.length}`);
        console.log(`      Root: ${tsResult.root}`);

        // Parse Rust results
        const rustDeactivates = data.deactivates.map((deactivate: any) => [
          BigInt(deactivate.c1_x),
          BigInt(deactivate.c1_y),
          BigInt(deactivate.c2_x),
          BigInt(deactivate.c2_y),
          BigInt(deactivate.shared_key_hash)
        ]);

        const rustLeaves = data.leaves.map((leaf: string) => BigInt(leaf));
        const rustRoot = BigInt(data.root);

        console.log(`\n    Rust Results:`);
        console.log(`      Number of deactivates: ${rustDeactivates.length}`);
        console.log(`      Number of leaves: ${rustLeaves.length}`);
        console.log(`      Root: ${rustRoot}`);

        // Verify structure
        expect(tsResult.deactivates.length).to.equal(
          accounts.length,
          'Should have one deactivate entry per account'
        );
        expect(tsResult.leaves.length).to.equal(
          accounts.length,
          'Should have one leaf per account'
        );

        // NOTE: Due to randomness in encrypt_odevity, each run produces different ciphertexts.
        // We cannot directly compare deactivates and leaves between Rust and TypeScript.
        // Instead, we verify the structure and consistency within each implementation.

        console.log(`\n    Verification:`);
        console.log(
          `      ✓ Structure: ${tsResult.deactivates.length} deactivates, ${tsResult.leaves.length} leaves`
        );

        // Verify each deactivate entry has correct structure
        tsResult.deactivates.forEach((deactivate, idx) => {
          expect(deactivate.length).to.equal(5, `Deactivate ${idx} should have 5 elements`);
          deactivate.forEach((element, elemIdx) => {
            expect(element).to.be.a('bigint', `Deactivate ${idx}[${elemIdx}] should be bigint`);
            expect(element > 0n).to.be.true;
          });
        });
        console.log(`      ✓ All deactivate entries have correct structure (5 elements each)`);

        // Verify leaves are computed correctly from deactivates
        tsResult.deactivates.forEach((deactivate, idx) => {
          const computedLeaf = poseidon(deactivate);
          expect(computedLeaf).to.equal(
            tsResult.leaves[idx],
            `Leaf ${idx} should match poseidon hash of deactivate`
          );
        });
        console.log(`      ✓ All leaves correctly computed from deactivates`);

        // Verify tree properties
        expect(tsResult.tree.DEPTH).to.equal(Number(data.tree_depth), 'Tree depth should match');
        expect(tsResult.tree.DEGREE).to.equal(Number(data.tree_degree), 'Tree degree should match');
        console.log(
          `      ✓ Tree properties match: depth=${tsResult.tree.DEPTH}, degree=${tsResult.tree.DEGREE}`
        );

        console.log(`\n    ✓ ${vector.name} test passed`);
        console.log('    ─────────────────────────────────────────────────────');
      });
    });
  });

  describe('2. genDeactivateRoot with Single Account', () => {
    it('should test deactivate root vector with single account', function () {
      const singleAccountVectors = filterByType(rustTestVectors, 'amaci_deactivate_root').filter(
        (v) => v.name.includes('single_account')
      );

      expect(singleAccountVectors.length).to.be.greaterThan(
        0,
        'Should have at least one single account vector'
      );

      singleAccountVectors.forEach((vector) => {
        const data = vector.data;

        // Validate required fields - fail fast if data is missing
        if (!data.coordinator_seed || !data.accounts || data.state_tree_depth === undefined) {
          throw new Error(
            `Missing required data in test vector "${vector.name}". ` +
              `Single account vectors must have: coordinator_seed, accounts, state_tree_depth`
          );
        }

        console.log(`\n  ${vector.name}:`);
        console.log(`    Description: ${vector.description}`);

        // Create coordinator keypair
        const coordinatorSeed = BigInt(data.coordinator_seed);
        const coordinator = EdDSAPoseidonKeypair.fromSecretKey(coordinatorSeed);

        // Parse single account
        const accounts: PubKey[] = data.accounts.map((account: any) => [
          BigInt(account.x),
          BigInt(account.y)
        ]);

        expect(accounts.length).to.equal(1, 'Should have exactly one account');
        console.log(`    Account: [${accounts[0][0]}, ${accounts[0][1]}]`);

        // Generate deactivate root
        const tsResult = coordinator.genDeactivateRoot(accounts, Number(data.state_tree_depth));

        console.log(`\n    Results:`);
        console.log(`      Deactivates: ${tsResult.deactivates.length}`);
        console.log(`      Leaves: ${tsResult.leaves.length}`);
        console.log(`      Root: ${tsResult.root}`);

        // Verify
        expect(tsResult.deactivates.length).to.equal(1, 'Should have one deactivate entry');
        expect(tsResult.leaves.length).to.equal(1, 'Should have one leaf');
        expect(tsResult.deactivates[0].length).to.equal(5, 'Deactivate should have 5 elements');

        // Verify leaf computation
        const computedLeaf = poseidon(tsResult.deactivates[0]);
        expect(computedLeaf).to.equal(
          tsResult.leaves[0],
          'Leaf should match poseidon hash of deactivate'
        );

        console.log(`    ✓ Single account test passed`);
      });
    });
  });

  describe('3. Consistency Across Different State Tree Depths', () => {
    it('should generate consistent results for different depths', function () {
      // Test with the same accounts but different state tree depths
      const coordinatorSeed = 54321n;
      const coordinator = EdDSAPoseidonKeypair.fromSecretKey(coordinatorSeed);

      // Create test accounts
      const accountSeeds = [11111n, 22222n, 33333n];
      const accounts: PubKey[] = accountSeeds.map((seed) => {
        const kp = EdDSAPoseidonKeypair.fromSecretKey(seed);
        return kp.getPublicKey().toPoints();
      });

      const depths = [2, 3, 4];
      const results: any[] = [];

      depths.forEach((depth) => {
        const result = coordinator.genDeactivateRoot(accounts, depth);
        results.push({
          depth,
          deactivates: result.deactivates.length,
          leaves: result.leaves.length,
          treeDepth: result.tree.DEPTH,
          treeDegree: result.tree.DEGREE,
          root: result.root
        });

        console.log(`\n  Depth ${depth}:`);
        console.log(`    Deactivates: ${result.deactivates.length}`);
        console.log(`    Leaves: ${result.leaves.length}`);
        console.log(`    Tree depth: ${result.tree.DEPTH}`);
        console.log(`    Tree degree: ${result.tree.DEGREE}`);
        console.log(`    Root: ${result.root}`);
      });

      // Verify all have same number of deactivates and leaves
      const firstResult = results[0];
      results.forEach((result, idx) => {
        expect(result.deactivates).to.equal(
          firstResult.deactivates,
          `Result ${idx} should have same number of deactivates`
        );
        expect(result.leaves).to.equal(
          firstResult.leaves,
          `Result ${idx} should have same number of leaves`
        );
      });

      // Verify tree depths are correctly calculated (state_tree_depth + 2)
      results.forEach((result, idx) => {
        const expectedTreeDepth = depths[idx] + 2;
        expect(result.treeDepth).to.equal(
          expectedTreeDepth,
          `Tree depth should be state_tree_depth + 2`
        );
      });

      // Note: Roots will be different due to different tree depths
      console.log(`\n  ✓ All depths produce consistent structure`);
    });
  });

  describe('4. Deactivate Entry Structure Validation', () => {
    it('should validate the structure of deactivate entries', function () {
      const coordinator = EdDSAPoseidonKeypair.fromSecretKey(99999n);
      const account = EdDSAPoseidonKeypair.fromSecretKey(88888n);

      const result = coordinator.genDeactivateRoot([account.getPublicKey().toPoints()], 2);

      expect(result.deactivates.length).to.equal(1, 'Should have one deactivate entry');

      const deactivate = result.deactivates[0];
      console.log(`\n  Deactivate entry structure:`);
      console.log(`    c1.x: ${deactivate[0]}`);
      console.log(`    c1.y: ${deactivate[1]}`);
      console.log(`    c2.x: ${deactivate[2]}`);
      console.log(`    c2.y: ${deactivate[3]}`);
      console.log(`    shared_key_hash: ${deactivate[4]}`);

      // Validate each element is a positive bigint
      expect(deactivate.length).to.equal(5, 'Should have 5 elements');
      deactivate.forEach((element, idx) => {
        expect(element).to.be.a('bigint', `Element ${idx} should be bigint`);
        expect(element > 0n).to.be.true;
      });

      // Verify leaf is computed correctly
      const leaf = poseidon(deactivate);
      expect(leaf).to.equal(result.leaves[0], 'Leaf should be poseidon hash of deactivate');

      console.log(`\n  ✓ Deactivate entry structure is valid`);
    });
  });

  describe('5. Merkle Tree Root Consistency', () => {
    it('should produce consistent tree roots for same inputs', function () {
      const coordinator = EdDSAPoseidonKeypair.fromSecretKey(77777n);
      const account1 = EdDSAPoseidonKeypair.fromSecretKey(11111n);
      const account2 = EdDSAPoseidonKeypair.fromSecretKey(22222n);

      const accounts = [account1.getPublicKey().toPoints(), account2.getPublicKey().toPoints()];

      // Generate root multiple times
      const result1 = coordinator.genDeactivateRoot(accounts, 3);
      const result2 = coordinator.genDeactivateRoot(accounts, 3);

      console.log(`\n  First run root: ${result1.root}`);
      console.log(`  Second run root: ${result2.root}`);

      // Note: Due to randomness in encrypt_odevity, roots will be different
      // This is expected behavior - each run generates new random ciphertexts
      console.log(`\n  ✓ Both runs produce valid roots (randomness expected)`);

      // Verify structure is consistent
      expect(result1.deactivates.length).to.equal(
        result2.deactivates.length,
        'Both runs should have same number of deactivates'
      );
      expect(result1.leaves.length).to.equal(
        result2.leaves.length,
        'Both runs should have same number of leaves'
      );
      expect(result1.tree.DEPTH).to.equal(
        result2.tree.DEPTH,
        'Both runs should have same tree depth'
      );
      expect(result1.tree.DEGREE).to.equal(
        result2.tree.DEGREE,
        'Both runs should have same tree degree'
      );

      console.log(`  ✓ Structure is consistent across runs`);
    });
  });
});
