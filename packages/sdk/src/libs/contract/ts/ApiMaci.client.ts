/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate';
import { Coin, StdFee } from '@cosmjs/amino';
import {
  Uint256,
  Timestamp,
  Uint64,
  VotingPowerMode,
  InstantiateMsg,
  PubKey,
  RoundInfo,
  VotingTime,
  VotingPowerArgs,
  ExecuteMsg,
  Uint128,
  MessageData,
  Groth16ProofType,
  PlonkProofType,
  QueryMsg,
  Addr,
  PeriodStatus,
  Period,
  Boolean,
  Binary,
  OracleWhitelistConfig,
  NullableUint256,
  ArrayOfString,
  WhitelistConfig
} from './ApiMaci.types';
export interface ApiMaciReadOnlyInterface {
  contractAddress: string;
  getRoundInfo: () => Promise<RoundInfo>;
  getVotingTime: () => Promise<VotingTime>;
  getPeriod: () => Promise<Period>;
  getNumSignUp: () => Promise<Uint256>;
  getMsgChainLength: () => Promise<Uint256>;
  getProcessedMsgCount: () => Promise<Uint256>;
  getProcessedUserCount: () => Promise<Uint256>;
  getResult: ({ index }: { index: Uint256 }) => Promise<Uint256>;
  getAllResult: () => Promise<Uint256>;
  getStateIdxInc: ({ address }: { address: Addr }) => Promise<Uint256>;
  getVoiceCreditBalance: ({ index }: { index: Uint256 }) => Promise<Uint256>;
  isWhiteList: ({
    amount,
    certificate,
    pubkey
  }: {
    amount: Uint256;
    certificate: string;
    pubkey: PubKey;
  }) => Promise<Boolean>;
  whiteBalanceOf: ({
    amount,
    certificate,
    pubkey
  }: {
    amount: Uint256;
    certificate: string;
    pubkey: PubKey;
  }) => Promise<Uint256>;
  whiteInfo: ({ pubkey }: { pubkey: PubKey }) => Promise<WhitelistConfig>;
  maxWhitelistNum: () => Promise<Uint128>;
  voteOptionMap: () => Promise<ArrayOfString>;
  maxVoteOptions: () => Promise<Uint256>;
  queryTotalFeeGrant: () => Promise<Uint128>;
  queryCircuitType: () => Promise<Uint256>;
  queryCertSystem: () => Promise<Uint256>;
  queryOracleWhitelistConfig: () => Promise<OracleWhitelistConfig>;
  queryCurrentStateCommitment: () => Promise<Uint256>;
  getStateTreeRoot: () => Promise<Uint256>;
  getNode: ({ index }: { index: Uint256 }) => Promise<Uint256>;
  signuped: ({ pubkey }: { pubkey: PubKey }) => Promise<NullableUint256>;
}
export class ApiMaciQueryClient implements ApiMaciReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getRoundInfo = this.getRoundInfo.bind(this);
    this.getVotingTime = this.getVotingTime.bind(this);
    this.getPeriod = this.getPeriod.bind(this);
    this.getNumSignUp = this.getNumSignUp.bind(this);
    this.getMsgChainLength = this.getMsgChainLength.bind(this);
    this.getProcessedMsgCount = this.getProcessedMsgCount.bind(this);
    this.getProcessedUserCount = this.getProcessedUserCount.bind(this);
    this.getResult = this.getResult.bind(this);
    this.getAllResult = this.getAllResult.bind(this);
    this.getStateIdxInc = this.getStateIdxInc.bind(this);
    this.getVoiceCreditBalance = this.getVoiceCreditBalance.bind(this);
    this.isWhiteList = this.isWhiteList.bind(this);
    this.whiteBalanceOf = this.whiteBalanceOf.bind(this);
    this.whiteInfo = this.whiteInfo.bind(this);
    this.maxWhitelistNum = this.maxWhitelistNum.bind(this);
    this.voteOptionMap = this.voteOptionMap.bind(this);
    this.maxVoteOptions = this.maxVoteOptions.bind(this);
    this.queryTotalFeeGrant = this.queryTotalFeeGrant.bind(this);
    this.queryCircuitType = this.queryCircuitType.bind(this);
    this.queryCertSystem = this.queryCertSystem.bind(this);
    this.queryOracleWhitelistConfig = this.queryOracleWhitelistConfig.bind(this);
    this.queryCurrentStateCommitment = this.queryCurrentStateCommitment.bind(this);
    this.getStateTreeRoot = this.getStateTreeRoot.bind(this);
    this.getNode = this.getNode.bind(this);
    this.signuped = this.signuped.bind(this);
  }
  getRoundInfo = async (): Promise<RoundInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_round_info: {}
    });
  };
  getVotingTime = async (): Promise<VotingTime> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_voting_time: {}
    });
  };
  getPeriod = async (): Promise<Period> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_period: {}
    });
  };
  getNumSignUp = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_num_sign_up: {}
    });
  };
  getMsgChainLength = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_msg_chain_length: {}
    });
  };
  getProcessedMsgCount = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_processed_msg_count: {}
    });
  };
  getProcessedUserCount = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_processed_user_count: {}
    });
  };
  getResult = async ({ index }: { index: Uint256 }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_result: {
        index
      }
    });
  };
  getAllResult = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_result: {}
    });
  };
  getStateIdxInc = async ({ address }: { address: Addr }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state_idx_inc: {
        address
      }
    });
  };
  getVoiceCreditBalance = async ({ index }: { index: Uint256 }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_voice_credit_balance: {
        index
      }
    });
  };
  isWhiteList = async ({
    amount,
    certificate,
    pubkey
  }: {
    amount: Uint256;
    certificate: string;
    pubkey: PubKey;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_white_list: {
        amount,
        certificate,
        pubkey
      }
    });
  };
  whiteBalanceOf = async ({
    amount,
    certificate,
    pubkey
  }: {
    amount: Uint256;
    certificate: string;
    pubkey: PubKey;
  }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      white_balance_of: {
        amount,
        certificate,
        pubkey
      }
    });
  };
  whiteInfo = async ({ pubkey }: { pubkey: PubKey }): Promise<WhitelistConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      white_info: {
        pubkey
      }
    });
  };
  maxWhitelistNum = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      max_whitelist_num: {}
    });
  };
  voteOptionMap = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vote_option_map: {}
    });
  };
  maxVoteOptions = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      max_vote_options: {}
    });
  };
  queryTotalFeeGrant = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_total_fee_grant: {}
    });
  };
  queryCircuitType = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_circuit_type: {}
    });
  };
  queryCertSystem = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_cert_system: {}
    });
  };
  queryOracleWhitelistConfig = async (): Promise<OracleWhitelistConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_oracle_whitelist_config: {}
    });
  };
  queryCurrentStateCommitment = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_current_state_commitment: {}
    });
  };
  getStateTreeRoot = async (): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state_tree_root: {}
    });
  };
  getNode = async ({ index }: { index: Uint256 }): Promise<Uint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_node: {
        index
      }
    });
  };
  signuped = async ({ pubkey }: { pubkey: PubKey }): Promise<NullableUint256> => {
    return this.client.queryContractSmart(this.contractAddress, {
      signuped: {
        pubkey
      }
    });
  };
}
export interface ApiMaciInterface extends ApiMaciReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setRoundInfo: (
    {
      roundInfo
    }: {
      roundInfo: RoundInfo;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  setVoteOptionsMap: (
    {
      voteOptionMap
    }: {
      voteOptionMap: string[];
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  signUp: (
    {
      amount,
      certificate,
      pubkey
    }: {
      amount: Uint256;
      certificate: string;
      pubkey: PubKey;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  startProcessPeriod: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  publishMessage: (
    {
      encPubKey,
      message
    }: {
      encPubKey: PubKey;
      message: MessageData;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  publishMessageBatch: (
    {
      encPubKeys,
      messages
    }: {
      encPubKeys: PubKey[];
      messages: MessageData[];
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  processMessage: (
    {
      groth16Proof,
      newStateCommitment,
      plonkProof
    }: {
      groth16Proof?: Groth16ProofType;
      newStateCommitment: Uint256;
      plonkProof?: PlonkProofType;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  stopProcessingPeriod: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  processTally: (
    {
      groth16Proof,
      newTallyCommitment,
      plonkProof
    }: {
      groth16Proof?: Groth16ProofType;
      newTallyCommitment: Uint256;
      plonkProof?: PlonkProofType;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  stopTallyingPeriod: (
    {
      results,
      salt
    }: {
      results: Uint256[];
      salt: Uint256;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  bond: (fee?: number | StdFee | 'auto', memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: (
    {
      amount
    }: {
      amount?: Uint128;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class ApiMaciClient extends ApiMaciQueryClient implements ApiMaciInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setRoundInfo = this.setRoundInfo.bind(this);
    this.setVoteOptionsMap = this.setVoteOptionsMap.bind(this);
    this.signUp = this.signUp.bind(this);
    this.startProcessPeriod = this.startProcessPeriod.bind(this);
    this.publishMessage = this.publishMessage.bind(this);
    this.publishMessageBatch = this.publishMessageBatch.bind(this);
    this.processMessage = this.processMessage.bind(this);
    this.stopProcessingPeriod = this.stopProcessingPeriod.bind(this);
    this.processTally = this.processTally.bind(this);
    this.stopTallyingPeriod = this.stopTallyingPeriod.bind(this);
    this.bond = this.bond.bind(this);
    this.withdraw = this.withdraw.bind(this);
  }
  setRoundInfo = async (
    {
      roundInfo
    }: {
      roundInfo: RoundInfo;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_round_info: {
          round_info: roundInfo
        }
      },
      fee,
      memo,
      _funds
    );
  };
  setVoteOptionsMap = async (
    {
      voteOptionMap
    }: {
      voteOptionMap: string[];
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_vote_options_map: {
          vote_option_map: voteOptionMap
        }
      },
      fee,
      memo,
      _funds
    );
  };
  signUp = async (
    {
      amount,
      certificate,
      pubkey
    }: {
      amount: Uint256;
      certificate: string;
      pubkey: PubKey;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        sign_up: {
          amount,
          certificate,
          pubkey
        }
      },
      fee,
      memo,
      _funds
    );
  };
  startProcessPeriod = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        start_process_period: {}
      },
      fee,
      memo,
      _funds
    );
  };
  publishMessage = async (
    {
      encPubKey,
      message
    }: {
      encPubKey: PubKey;
      message: MessageData;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        publish_message: {
          enc_pub_key: encPubKey,
          message
        }
      },
      fee,
      memo,
      _funds
    );
  };
  publishMessageBatch = async (
    {
      encPubKeys,
      messages
    }: {
      encPubKeys: PubKey[];
      messages: MessageData[];
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        publish_message_batch: {
          enc_pub_keys: encPubKeys,
          messages
        }
      },
      fee,
      memo,
      _funds
    );
  };
  processMessage = async (
    {
      groth16Proof,
      newStateCommitment,
      plonkProof
    }: {
      groth16Proof?: Groth16ProofType;
      newStateCommitment: Uint256;
      plonkProof?: PlonkProofType;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        process_message: {
          groth16_proof: groth16Proof,
          new_state_commitment: newStateCommitment,
          plonk_proof: plonkProof
        }
      },
      fee,
      memo,
      _funds
    );
  };
  stopProcessingPeriod = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        stop_processing_period: {}
      },
      fee,
      memo,
      _funds
    );
  };
  processTally = async (
    {
      groth16Proof,
      newTallyCommitment,
      plonkProof
    }: {
      groth16Proof?: Groth16ProofType;
      newTallyCommitment: Uint256;
      plonkProof?: PlonkProofType;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        process_tally: {
          groth16_proof: groth16Proof,
          new_tally_commitment: newTallyCommitment,
          plonk_proof: plonkProof
        }
      },
      fee,
      memo,
      _funds
    );
  };
  stopTallyingPeriod = async (
    {
      results,
      salt
    }: {
      results: Uint256[];
      salt: Uint256;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        stop_tallying_period: {
          results,
          salt
        }
      },
      fee,
      memo,
      _funds
    );
  };
  bond = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        bond: {}
      },
      fee,
      memo,
      _funds
    );
  };
  withdraw = async (
    {
      amount
    }: {
      amount?: Uint128;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw: {
          amount
        }
      },
      fee,
      memo,
      _funds
    );
  };
}
