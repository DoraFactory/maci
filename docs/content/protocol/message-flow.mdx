# æ¶ˆæ¯æµç¨‹

æœ¬èŠ‚è¯¦ç»†ä»‹ç» MACI ä¸­æ¶ˆæ¯çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼Œä»æŠ•ç¥¨è€…ç”Ÿæˆæ¶ˆæ¯åˆ° Coordinator å¤„ç†æ¶ˆæ¯å¹¶ç”Ÿæˆè¯æ˜çš„å…¨è¿‡ç¨‹ã€‚

## æ¶ˆæ¯ç”Ÿå‘½å‘¨æœŸæ¦‚è§ˆ

```mermaid
graph TD
    A[æŠ•ç¥¨è€…åˆ›å»ºæ¶ˆæ¯] --> B[åŠ å¯†å’Œç­¾å]
    B --> C[æäº¤åˆ°é“¾ä¸Š]
    C --> D[å­˜å‚¨åœ¨æ¶ˆæ¯é˜Ÿåˆ—]
    D --> E[æŠ•ç¥¨æœŸç»“æŸ]
    E --> F[Coordinator ä¸‹è½½]
    F --> G[è§£å¯†æ¶ˆæ¯]
    G --> H[éªŒè¯ç­¾å]
    H --> I[æŒ‰ Nonce å¤„ç†]
    I --> J[æ›´æ–°çŠ¶æ€æ ‘]
    J --> K[ç”Ÿæˆ ZK è¯æ˜]
    K --> L[æäº¤åˆ°é“¾ä¸Š]
    L --> M[éªŒè¯å¹¶å‘å¸ƒç»“æœ]
```

## æŠ•ç¥¨è€…ç«¯ï¼šæ¶ˆæ¯ç”Ÿæˆ

### æ­¥éª¤ 1: å‡†å¤‡æŠ•ç¥¨æ•°æ®

æŠ•ç¥¨è€…é¦–å…ˆéœ€è¦å‡†å¤‡è¦æŠ•ç¥¨çš„æ•°æ®ï¼š

```typescript
// æŠ•ç¥¨é€‰é¡¹
const selectedOptions = [
  { idx: 0, vc: 5 },  // ç»™é€‰é¡¹ 0 æŠ• 5 ç¥¨
  { idx: 1, vc: 3 },  // ç»™é€‰é¡¹ 1 æŠ• 3 ç¥¨
  { idx: 2, vc: 2 },  // ç»™é€‰é¡¹ 2 æŠ• 2 ç¥¨
];

// éªŒè¯æŠ•ç¥¨æƒé‡
const totalCost = selectedOptions.reduce((sum, opt) => {
  return sum + (isQV ? opt.vc * opt.vc : opt.vc);
}, 0);

if (totalCost > voiceCredits) {
  throw new Error("æŠ•ç¥¨æƒé‡è¶…è¿‡å¯ç”¨é¢åº¦");
}
```

### æ­¥éª¤ 2: æ„é€ å‘½ä»¤

```typescript
function createVoteCommand(
  stateIndex: number,
  nonce: number,
  voteOption: { idx: number; vc: number },
  currentPubKey: Point,
  salt: bigint
): Command {
  return {
    nonce: BigInt(nonce),
    stateIndex: BigInt(stateIndex),
    voteOptionIndex: BigInt(voteOption.idx),
    newVoteWeight: BigInt(voteOption.vc),
    newPubKey: currentPubKey,  // é€šå¸¸ä¿æŒä¸å˜
    salt: salt
  };
}
```

### æ­¥éª¤ 3: æ‰“åŒ…å’Œå“ˆå¸Œ

```typescript
// æ‰“åŒ…å‘½ä»¤å­—æ®µ
function packCommand(command: Command): bigint {
  // å°† 5 ä¸ªå­—æ®µæ‰“åŒ…æˆä¸€ä¸ª bigint
  let packed = BigInt(0);
  
  // nonce (8 bits)
  packed |= (command.nonce & BigInt(0xFF));
  
  // stateIndex (24 bits)
  packed |= ((command.stateIndex & BigInt(0xFFFFFF)) << BigInt(8));
  
  // voteOptionIndex (8 bits)
  packed |= ((command.voteOptionIndex & BigInt(0xFF)) << BigInt(32));
  
  // newVoteWeight (24 bits)
  packed |= ((command.newVoteWeight & BigInt(0xFFFFFF)) << BigInt(40));
  
  // salt (remaining bits)
  packed |= (command.salt << BigInt(64));
  
  return packed;
}

// è®¡ç®—å‘½ä»¤å“ˆå¸Œ
function hashCommand(command: Command): bigint {
  const packed = packCommand(command);
  return poseidon([
    packed,
    command.newPubKey[0],
    command.newPubKey[1]
  ]);
}
```

### æ­¥éª¤ 4: ç­¾å

```typescript
// ä½¿ç”¨ç§é’¥å¯¹å‘½ä»¤å“ˆå¸Œç­¾å
const commandHash = hashCommand(command);
const signature = sign(voterPrivateKey, commandHash);

// ç­¾åç»“æ„
// signature = {
//   R8: [x, y],  // æ›²çº¿ä¸Šçš„ç‚¹
//   S: bigint    // æ ‡é‡
// }
```

### æ­¥éª¤ 5: åŠ å¯†

```typescript
// ç”Ÿæˆ ECDH å…±äº«å¯†é’¥
const sharedKey = genEcdhSharedKey(
  voterPrivateKey,
  coordinatorPublicKey
);

// åŠ å¯†å‘½ä»¤
const encryptedData = encrypt(
  {
    packed: packCommand(command),
    newPubKeyX: command.newPubKey[0],
    newPubKeyY: command.newPubKey[1],
    signatureR8X: signature.R8[0],
    signatureR8Y: signature.R8[1],
    signatureS: signature.S
  },
  sharedKey
);
```

### æ­¥éª¤ 6: æäº¤åˆ°é“¾ä¸Š

```typescript
// æ„é€ æ¶ˆæ¯
const message = {
  msgType: 1,  // 1 = æŠ•ç¥¨æ¶ˆæ¯
  data: encryptedData  // 10 ä¸ªåŠ å¯†çš„å­—æ®µ
};

// æäº¤åˆ° MACI åˆçº¦
await maciContract.publishMessage(message);
```

## å®Œæ•´çš„æŠ•ç¥¨æ¶ˆæ¯ç”Ÿæˆç¤ºä¾‹

```typescript
async function generateAndSubmitVote(
  voterAccount: {
    privateKey: bigint;
    publicKey: Point;
    stateIndex: number;
    nonce: number;
  },
  coordinatorPubKey: Point,
  contractAddress: string,
  voteOptions: { idx: number; vc: number }[]
) {
  // å¯¹æ¯ä¸ªæŠ•ç¥¨é€‰é¡¹ç”Ÿæˆä¸€æ¡æ¶ˆæ¯
  for (const option of voteOptions) {
    // 1. ç”Ÿæˆéšæœºç›å€¼
    const salt = genRandomSalt();
    
    // 2. åˆ›å»ºå‘½ä»¤
    const command = {
      nonce: BigInt(voterAccount.nonce),
      stateIndex: BigInt(voterAccount.stateIndex),
      voteOptionIndex: BigInt(option.idx),
      newVoteWeight: BigInt(option.vc),
      newPubKey: voterAccount.publicKey,
      salt: salt
    };
    
    // 3. è®¡ç®—å“ˆå¸Œ
    const commandHash = hashCommand(command);
    
    // 4. ç­¾å
    const signature = sign(voterAccount.privateKey, commandHash);
    
    // 5. ECDH å…±äº«å¯†é’¥
    const sharedKey = genEcdhSharedKey(
      voterAccount.privateKey,
      coordinatorPubKey
    );
    
    // 6. åŠ å¯†
    const encryptedData = encrypt(
      command,
      signature,
      sharedKey
    );
    
    // 7. æ„é€ æ¶ˆæ¯
    const message = {
      msgType: 1,
      data: encryptedData
    };
    
    // 8. æäº¤åˆ°é“¾ä¸Š
    const tx = await contract.publishMessage(message);
    await tx.wait();
    
    console.log(`æ¶ˆæ¯ ${voterAccount.nonce} å·²æäº¤`);
    
    // 9. å¢åŠ æœ¬åœ° nonceï¼ˆæ³¨æ„ï¼šé“¾ä¸Š nonce åªåœ¨å¤„ç†æ—¶æ›´æ–°ï¼‰
    voterAccount.nonce++;
  }
}
```

## Coordinator ç«¯ï¼šæ¶ˆæ¯å¤„ç†

### æ­¥éª¤ 1: ä¸‹è½½æ¶ˆæ¯

æŠ•ç¥¨æœŸç»“æŸåï¼ŒCoordinator ä»é“¾ä¸Šä¸‹è½½æ‰€æœ‰æ¶ˆæ¯ï¼š

```typescript
async function downloadMessages(
  contractAddress: string
): Promise<Message[]> {
  // æŸ¥è¯¢åˆçº¦è·å–æ‰€æœ‰æ¶ˆæ¯
  const messages = await contract.getMessages();
  
  console.log(`ä¸‹è½½äº† ${messages.length} æ¡æ¶ˆæ¯`);
  
  return messages;
}
```

### æ­¥éª¤ 2: è§£å¯†æ¶ˆæ¯

```typescript
function decryptMessage(
  message: Message,
  coordinatorPrivateKey: bigint,
  voterPublicKey: Point
): Command {
  // 1. ç”Ÿæˆ ECDH å…±äº«å¯†é’¥
  const sharedKey = genEcdhSharedKey(
    coordinatorPrivateKey,
    voterPublicKey
  );
  
  // 2. è§£å¯†æ•°æ®
  const decrypted = decrypt(message.data, sharedKey);
  
  // 3. è§£åŒ…å‘½ä»¤
  const command = unpackCommand(decrypted);
  
  return command;
}
```

### æ­¥éª¤ 3: éªŒè¯ç­¾å

```typescript
function validateCommand(
  command: Command,
  voterPublicKey: Point
): boolean {
  // 1. é‡æ–°è®¡ç®—å‘½ä»¤å“ˆå¸Œ
  const commandHash = hashCommand(command);
  
  // 2. éªŒè¯ EdDSA ç­¾å
  const isValid = verifySignature(
    commandHash,
    command.signature,
    voterPublicKey
  );
  
  if (!isValid) {
    console.log("ç­¾åéªŒè¯å¤±è´¥");
    return false;
  }
  
  return true;
}
```

### æ­¥éª¤ 4: æŒ‰åºå¤„ç†æ¶ˆæ¯

```typescript
async function processMessages(
  messages: Message[],
  coordinatorPrivateKey: bigint,
  initialStateTree: MerkleTree
): Promise<ProcessingResult> {
  const stateTree = initialStateTree.clone();
  const processedCommands = [];
  
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    
    // 1. è·å–æŠ•ç¥¨è€…çŠ¶æ€
    const stateLeaf = stateTree.getLeaf(message.stateIndex);
    const voterPubKey = stateLeaf.pubKey;
    
    // 2. è§£å¯†
    const command = decryptMessage(
      message,
      coordinatorPrivateKey,
      voterPubKey
    );
    
    // 3. éªŒè¯ç­¾å
    if (!validateCommand(command, voterPubKey)) {
      console.log(`æ¶ˆæ¯ ${i}: ç­¾åæ— æ•ˆï¼Œè·³è¿‡`);
      continue;
    }
    
    // 4. éªŒè¯ Nonce
    if (command.nonce !== stateLeaf.nonce) {
      console.log(`æ¶ˆæ¯ ${i}: Nonce ä¸åŒ¹é…ï¼Œè·³è¿‡`);
      continue;
    }
    
    // 5. å¤„ç†å‘½ä»¤
    const newStateLeaf = applyCommand(stateLeaf, command);
    
    // 6. æ›´æ–°çŠ¶æ€æ ‘
    stateTree.update(command.stateIndex, newStateLeaf);
    
    // 7. è®°å½•å·²å¤„ç†çš„å‘½ä»¤
    processedCommands.push(command);
    
    console.log(`æ¶ˆæ¯ ${i}: å¤„ç†æˆåŠŸ`);
  }
  
  return {
    newStateRoot: stateTree.getRoot(),
    processedCommands: processedCommands,
    stateTree: stateTree
  };
}
```

### æ­¥éª¤ 5: æ›´æ–°çŠ¶æ€

```typescript
function applyCommand(
  currentState: StateLeaf,
  command: Command
): StateLeaf {
  // 1. æ›´æ–°å…¬é’¥ï¼ˆå¦‚æœæœ‰å˜åŒ–ï¼‰
  const newPubKey = command.newPubKey;
  
  // 2. è®¡ç®—æŠ•ç¥¨æˆæœ¬
  const cost = calculateVoteCost(
    command.newVoteWeight,
    isQuadraticVoting
  );
  
  // 3. æ£€æŸ¥ä½™é¢
  if (cost > currentState.voiceCreditBalance) {
    throw new Error("ä½™é¢ä¸è¶³");
  }
  
  // 4. æ›´æ–°æŠ•ç¥¨é€‰é¡¹æ ‘
  const newVoTree = updateVoteOptionTree(
    currentState.voteOptionTreeRoot,
    command.voteOptionIndex,
    command.newVoteWeight
  );
  
  // 5. è¿”å›æ–°çŠ¶æ€
  return {
    pubKey: newPubKey,
    voiceCreditBalance: currentState.voiceCreditBalance - cost,
    voteOptionTreeRoot: newVoTree.getRoot(),
    nonce: currentState.nonce + BigInt(1)  // Nonce +1
  };
}
```

## é›¶çŸ¥è¯†è¯æ˜ç”Ÿæˆ

å¤„ç†å®Œæ‰€æœ‰æ¶ˆæ¯åï¼ŒCoordinator ç”Ÿæˆé›¶çŸ¥è¯†è¯æ˜ï¼š

### ProcessMessages è¯æ˜

```typescript
async function generateProcessMessagesProof(
  messages: Message[],
  coordinatorPrivateKey: bigint,
  initialStateRoot: bigint,
  finalStateRoot: bigint
): Promise<Proof> {
  // å‡†å¤‡ç”µè·¯è¾“å…¥
  const circuitInputs = {
    // å…¬å¼€è¾“å…¥
    coordPubKey: genPublicKey(coordinatorPrivateKey),
    msgRoot: computeMessageRoot(messages),
    currentStateRoot: initialStateRoot,
    newStateRoot: finalStateRoot,
    
    // ç§æœ‰è¾“å…¥
    coordPrivKey: coordinatorPrivateKey,
    messages: messages,
    currentStateLeavesPathElements: [...],
    newStateLeavesPathElements: [...],
    // ... æ›´å¤šè¾“å…¥
  };
  
  // è°ƒç”¨ snarkjs æˆ–å…¶ä»– ZK è¯æ˜åº“
  const proof = await generateProof(
    'ProcessMessages',
    circuitInputs
  );
  
  return proof;
}
```

### Tally è¯æ˜

```typescript
async function generateTallyProof(
  stateTree: MerkleTree,
  results: bigint[]
): Promise<Proof> {
  // å‡†å¤‡ç”µè·¯è¾“å…¥
  const circuitInputs = {
    // å…¬å¼€è¾“å…¥
    stateRoot: stateTree.getRoot(),
    tallyResult: results,
    
    // ç§æœ‰è¾“å…¥
    stateLeaves: stateTree.getAllLeaves(),
    statePathElements: [...],
    // ... æ›´å¤šè¾“å…¥
  };
  
  // ç”Ÿæˆè¯æ˜
  const proof = await generateProof(
    'TallyVotes',
    circuitInputs
  );
  
  return proof;
}
```

## æ—¶é—´çº¿ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´æŠ•ç¥¨è½®æ¬¡çš„æ—¶é—´çº¿ï¼š

```mermaid
gantt
    title MACI æŠ•ç¥¨è½®æ¬¡æ—¶é—´çº¿
    dateFormat HH:mm
    section å‡†å¤‡é˜¶æ®µ
    åˆ›å»ºè½®æ¬¡           :done, 00:00, 00:10
    å‘å¸ƒ Coordinator å…¬é’¥ :done, 00:10, 00:15
    section æ³¨å†Œé˜¶æ®µ
    ç”¨æˆ· A æ³¨å†Œ        :done, 00:15, 00:20
    ç”¨æˆ· B æ³¨å†Œ        :done, 00:20, 00:25
    ç”¨æˆ· C æ³¨å†Œ        :done, 00:25, 00:30
    section æŠ•ç¥¨é˜¶æ®µ
    ç”¨æˆ· A æŠ•ç¥¨        :done, 00:30, 00:35
    ç”¨æˆ· B æŠ•ç¥¨        :done, 00:35, 00:40
    ç”¨æˆ· A æ”¹æŠ•        :done, 00:40, 00:45
    ç”¨æˆ· C æŠ•ç¥¨        :done, 00:45, 00:50
    æŠ•ç¥¨æœŸç»“æŸ         :milestone, 01:00, 0d
    section å¤„ç†é˜¶æ®µ
    ä¸‹è½½æ¶ˆæ¯           :active, 01:00, 01:10
    è§£å¯†å’Œå¤„ç†         :active, 01:10, 02:00
    ç”Ÿæˆ PM è¯æ˜       :active, 02:00, 02:30
    æäº¤ PM è¯æ˜       :active, 02:30, 02:35
    ç”Ÿæˆ Tally è¯æ˜    :active, 02:35, 03:00
    æäº¤ Tally è¯æ˜    :active, 03:00, 03:05
    section ç»“æœé˜¶æ®µ
    éªŒè¯è¯æ˜           :done, 03:05, 03:10
    å‘å¸ƒç»“æœ           :milestone, 03:10, 0d
```

## æ¶ˆæ¯å¤„ç†çš„è¯¦ç»†ç¤ºä¾‹

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå…·ä½“ä¾‹å­æ¥ç†è§£æ•´ä¸ªæµç¨‹ï¼š

### åœºæ™¯è®¾ç½®

```typescript
// 3 ä¸ªæŠ•ç¥¨è€…ï¼Œ5 ä¸ªæŠ•ç¥¨é€‰é¡¹
const voters = [
  { name: 'Alice', stateIdx: 0, voiceCredits: 100 },
  { name: 'Bob',   stateIdx: 1, voiceCredits: 100 },
  { name: 'Carol', stateIdx: 2, voiceCredits: 100 },
];

const options = ['Option 0', 'Option 1', 'Option 2', 'Option 3', 'Option 4'];
```

### æŠ•ç¥¨é˜¶æ®µ

```typescript
// Alice æŠ•ç¥¨ï¼ˆnonce=0ï¼‰
Alice.vote([
  { idx: 0, vc: 5 },  // ç»™é€‰é¡¹ 0 æŠ• 5 ç¥¨ï¼ˆæ¶ˆè€— 25 credits in QVï¼‰
  { idx: 1, vc: 3 },  // ç»™é€‰é¡¹ 1 æŠ• 3 ç¥¨ï¼ˆæ¶ˆè€— 9 credits in QVï¼‰
]);
// Alice å‰©ä½™: 100 - 25 - 9 = 66 credits

// Bob æŠ•ç¥¨ï¼ˆnonce=0ï¼‰
Bob.vote([
  { idx: 1, vc: 7 },  // ç»™é€‰é¡¹ 1 æŠ• 7 ç¥¨ï¼ˆæ¶ˆè€— 49 credits in QVï¼‰
]);
// Bob å‰©ä½™: 100 - 49 = 51 credits

// Alice æ”¹å˜ä¸»æ„ï¼ˆnonce=1ï¼‰
Alice.vote([
  { idx: 2, vc: 8 },  // ç»™é€‰é¡¹ 2 æŠ• 8 ç¥¨ï¼ˆæ¶ˆè€— 64 credits in QVï¼‰
]);
// Alice å‰©ä½™: 100 - 64 = 36 credits (ä¹‹å‰çš„æŠ•ç¥¨è¢«è¦†ç›–)

// Carol æŠ•ç¥¨ï¼ˆnonce=0ï¼‰
Carol.vote([
  { idx: 0, vc: 4 },  // ç»™é€‰é¡¹ 0 æŠ• 4 ç¥¨ï¼ˆæ¶ˆè€— 16 credits in QVï¼‰
  { idx: 3, vc: 6 },  // ç»™é€‰é¡¹ 3 æŠ• 6 ç¥¨ï¼ˆæ¶ˆè€— 36 credits in QVï¼‰
]);
// Carol å‰©ä½™: 100 - 16 - 36 = 48 credits
```

### å¤„ç†é˜¶æ®µ

```typescript
// Coordinator å¤„ç†æ¶ˆæ¯
const messages = await downloadMessages();

// æ¶ˆæ¯ 1: Alice vote (nonce=0)
processMessage(messages[0]);  // âœ“ æœ‰æ•ˆ
// çŠ¶æ€æ›´æ–°: Alice nonce -> 1, é€‰é¡¹ 0: +5, é€‰é¡¹ 1: +3

// æ¶ˆæ¯ 2: Bob vote (nonce=0)
processMessage(messages[1]);  // âœ“ æœ‰æ•ˆ
// çŠ¶æ€æ›´æ–°: Bob nonce -> 1, é€‰é¡¹ 1: +7

// æ¶ˆæ¯ 3: Alice revote (nonce=1)
processMessage(messages[2]);  // âœ“ æœ‰æ•ˆ (nonce åŒ¹é…)
// çŠ¶æ€æ›´æ–°: Alice nonce -> 2, é€‰é¡¹ 0: 0, é€‰é¡¹ 1: 0, é€‰é¡¹ 2: +8
// æ³¨æ„: Alice ä¹‹å‰çš„æŠ•ç¥¨è¢«å®Œå…¨è¦†ç›–

// æ¶ˆæ¯ 4: Carol vote (nonce=0)
processMessage(messages[3]);  // âœ“ æœ‰æ•ˆ
// çŠ¶æ€æ›´æ–°: Carol nonce -> 1, é€‰é¡¹ 0: +4, é€‰é¡¹ 3: +6
```

### æœ€ç»ˆç»“æœ

```typescript
const finalTally = {
  'Option 0': 4,    // Carol: 4
  'Option 1': 7,    // Bob: 7
  'Option 2': 8,    // Alice: 8
  'Option 3': 6,    // Carol: 6
  'Option 4': 0,    // æ— äººæŠ•ç¥¨
};

console.log("æœ€ç»ˆæŠ•ç¥¨ç»“æœ:", finalTally);
```

## é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯åœºæ™¯

**1. Nonce ä¸åŒ¹é…**

```typescript
// ç”¨æˆ·æäº¤äº† nonce=5 çš„æ¶ˆæ¯ï¼Œä½†å½“å‰ nonce=3
if (command.nonce !== currentState.nonce) {
  console.log(`æ¶ˆæ¯è¢«æ‹’ç»: nonce=${command.nonce}, æœŸæœ›=${currentState.nonce}`);
  continue;  // è·³è¿‡æ­¤æ¶ˆæ¯
}
```

**2. ç­¾åæ— æ•ˆ**

```typescript
if (!verifySignature(commandHash, signature, voterPubKey)) {
  console.log("æ¶ˆæ¯è¢«æ‹’ç»: ç­¾åéªŒè¯å¤±è´¥");
  continue;
}
```

**3. ä½™é¢ä¸è¶³**

```typescript
const cost = calculateVoteCost(command.newVoteWeight);
if (cost > currentState.voiceCreditBalance) {
  console.log("æ¶ˆæ¯è¢«æ‹’ç»: ä½™é¢ä¸è¶³");
  continue;
}
```

**4. å…¬é’¥ä¸åŒ¹é…**

```typescript
// æ¶ˆæ¯ç”¨æ—§å…¬é’¥ç­¾åï¼Œä½†çŠ¶æ€ä¸­å·²æ›´æ–°ä¸ºæ–°å…¬é’¥
if (voterPubKey !== currentState.pubKey) {
  console.log("æ¶ˆæ¯è¢«æ‹’ç»: å…¬é’¥å·²æ›´æ”¹");
  continue;
}
```

## ä¸‹ä¸€æ­¥

ç°åœ¨æ‚¨å·²ç»ç†è§£äº†æ¶ˆæ¯çš„å®Œæ•´æµç¨‹ï¼Œæ¥ä¸‹æ¥å¯ä»¥å­¦ä¹ ï¼š

- ğŸ›¡ï¸ [éšç§ä¿æŠ¤æœºåˆ¶](/protocol/privacy-protection) - äº†è§£å¦‚ä½•ä¿æŠ¤æŠ•ç¥¨éšç§
- ğŸ—ï¸ [åˆçº¦è®¾è®¡](/contracts/architecture) - å­¦ä¹ åˆçº¦å¦‚ä½•å­˜å‚¨å’ŒéªŒè¯æ¶ˆæ¯
- ğŸ’» [SDK ä½¿ç”¨æŒ‡å—](/sdk/installation) - ä½¿ç”¨ SDK åˆ›å»ºå’Œæäº¤æ¶ˆæ¯
