# å¯†ç å­¦æœºåˆ¶

MACI ä½¿ç”¨å¤šç§å¯†ç å­¦åŸè¯­æ¥å®ç°éšç§ä¿æŠ¤å’Œå®‰å…¨æ€§ã€‚æœ¬èŠ‚ä»‹ç»è¿™äº›å¯†ç å­¦æœºåˆ¶çš„å·¥ä½œåŸç†ã€‚

## å¯†ç å­¦ç»„ä»¶æ¦‚è§ˆ

MACI çš„å¯†ç å­¦æ ˆï¼š

```mermaid
graph TD
    A[Baby Jubjub æ›²çº¿] --> B[EdDSA ç­¾å]
    A --> C[ECDH å¯†é’¥äº¤æ¢]
    D[Poseidon å“ˆå¸Œ] --> E[æ¶ˆæ¯åŠ å¯†]
    D --> F[Merkle Tree]
    B --> G[æ¶ˆæ¯è®¤è¯]
    C --> E
    E --> H[æŠ•ç¥¨éšç§]
    F --> I[çŠ¶æ€ç®¡ç†]
    G --> J[é˜²ä¼ªé€ ]
```

## Baby Jubjub æ¤­åœ†æ›²çº¿

Baby Jubjub æ˜¯ä¸€ä¸ªä¸“ä¸ºé›¶çŸ¥è¯†è¯æ˜ä¼˜åŒ–çš„æ¤­åœ†æ›²çº¿ã€‚

### æ›²çº¿å‚æ•°

Baby Jubjub æ›²çº¿å®šä¹‰ä¸ºï¼š

```
axÂ² + yÂ² = 1 + dxÂ²yÂ²

å…¶ä¸­ï¼š
a = 168700
d = 168696
p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
```

### ç‰¹ç‚¹

- **ZK å‹å¥½**ï¼šåœ¨ ZK ç”µè·¯ä¸­è®¡ç®—é«˜æ•ˆ
- **å®‰å…¨æ€§é«˜**ï¼šåŸºäºæˆç†Ÿçš„å¯†ç å­¦å‡è®¾
- **å…¼å®¹æ€§å¥½**ï¼šä¸ Ethereum çš„ BN254 æ›²çº¿å…¼å®¹
- **EIP-2494 æ ‡å‡†**ï¼šéµå¾ª Ethereum æ”¹è¿›ææ¡ˆ

### ç‚¹æ“ä½œ

```typescript
// ç‚¹è¡¨ç¤º
type Point = [bigint, bigint];  // (x, y)

// ç‚¹åŠ æ³•
function pointAdd(P: Point, Q: Point): Point {
  // å®ç°æ›²çº¿ä¸Šçš„ç‚¹åŠ æ³•
  // åœ¨ ZK ç”µè·¯ä¸­é«˜æ•ˆ
}

// æ ‡é‡ä¹˜æ³•
function scalarMult(k: bigint, P: Point): Point {
  // k * P
  // ç”¨äºç”Ÿæˆå…¬é’¥å’Œ ECDH
}
```

### å…¬é’¥ç”Ÿæˆ

```typescript
// ä»ç§é’¥ç”Ÿæˆå…¬é’¥
function genPublicKey(privateKey: bigint): Point {
  const basePoint = getBasePoint();  // Baby Jubjub åŸºç‚¹
  return scalarMult(privateKey, basePoint);
}

// ç¤ºä¾‹
const privateKey = BigInt("12345678901234567890");
const publicKey = genPublicKey(privateKey);
// publicKey = [x, y] æ›²çº¿ä¸Šçš„ç‚¹
```

## EdDSA ç­¾å

EdDSAï¼ˆEdwards-curve Digital Signature Algorithmï¼‰æ˜¯ MACI ä½¿ç”¨çš„æ•°å­—ç­¾åæ–¹æ¡ˆã€‚

### ç­¾åç»“æ„

```typescript
interface Signature {
  R8: Point;      // ç­¾åçš„ R ç‚¹ï¼ˆæ›²çº¿ä¸Šçš„ç‚¹ï¼‰
  S: bigint;      // ç­¾åçš„ S å€¼ï¼ˆæ ‡é‡ï¼‰
}
```

### ç­¾åè¿‡ç¨‹

```mermaid
sequenceDiagram
    participant Signer as ç­¾åè€…
    participant Hash as Poseidon å“ˆå¸Œ
    participant Curve as Baby Jubjub æ›²çº¿
    Signer->>Hash: 1. è®¡ç®—æ¶ˆæ¯å“ˆå¸Œ M
    Signer->>Hash: 2. ç”Ÿæˆéšæœºæ•° r
    Signer->>Curve: 3. è®¡ç®— R8 = r * BasePoint
    Signer->>Hash: 4. è®¡ç®— h = Hash(R8, PubKey, M)
    Signer->>Signer: 5. è®¡ç®— S = r + h * privKey
    Signer->>Signer: 6. è¿”å›ç­¾å (R8, S)
```

### ç­¾åå®ç°

```typescript
function sign(privateKey: bigint, message: bigint): Signature {
  // 1. ç”Ÿæˆå…¬é’¥
  const publicKey = genPublicKey(privateKey);
  
  // 2. ç”Ÿæˆéšæœºæ•° rï¼ˆä»ç§é’¥æ´¾ç”Ÿï¼‰
  const r = deriveR(privateKey, message);
  
  // 3. è®¡ç®— R8 = r * BasePoint
  const R8 = scalarMult(r, getBasePoint());
  
  // 4. è®¡ç®—å“ˆå¸Œ h = Poseidon(R8.x, R8.y, PubKey.x, PubKey.y, message)
  const h = poseidon([
    R8[0], R8[1],
    publicKey[0], publicKey[1],
    message
  ]);
  
  // 5. è®¡ç®— S = r + h * privateKey (mod order)
  const S = (r + h * privateKey) % CURVE_ORDER;
  
  return { R8, S };
}
```

### éªŒè¯è¿‡ç¨‹

```typescript
function verifySignature(
  message: bigint,
  signature: Signature,
  publicKey: Point
): boolean {
  // 1. è®¡ç®— h = Poseidon(R8.x, R8.y, PubKey.x, PubKey.y, message)
  const h = poseidon([
    signature.R8[0], signature.R8[1],
    publicKey[0], publicKey[1],
    message
  ]);
  
  // 2. éªŒè¯ S * BasePoint == R8 + h * PubKey
  const lhs = scalarMult(signature.S, getBasePoint());
  const rhs = pointAdd(
    signature.R8,
    scalarMult(h, publicKey)
  );
  
  return lhs[0] === rhs[0] && lhs[1] === rhs[1];
}
```

### ç­¾åç¤ºä¾‹

```typescript
// åˆ›å»ºå¯†é’¥å¯¹
const keypair = genKeypair();

// è¦ç­¾åçš„æ¶ˆæ¯
const message = BigInt("0x123456789abcdef");

// ç”Ÿæˆç­¾å
const signature = sign(keypair.privateKey, message);

console.log("R8:", signature.R8);
console.log("S:", signature.S);

// éªŒè¯ç­¾å
const isValid = verifySignature(
  message,
  signature,
  keypair.publicKey
);
console.log("ç­¾åæœ‰æ•ˆ:", isValid);  // true
```

## Poseidon å“ˆå¸Œ

Poseidon æ˜¯ä¸€ä¸ªä¸“ä¸ºé›¶çŸ¥è¯†è¯æ˜ä¼˜åŒ–çš„å“ˆå¸Œå‡½æ•°ã€‚

### ç‰¹ç‚¹

- **ZK å‹å¥½**ï¼šåœ¨ ZK ç”µè·¯ä¸­çº¦æŸæ•°é‡å°‘
- **é«˜æ•ˆ**ï¼šæ¯” SHA-256 åœ¨ ZK ä¸­å¿«æ•°ç™¾å€
- **å®‰å…¨æ€§**ï¼šåŸºäº Sponge æ„é€ 
- **çµæ´»æ€§**ï¼šæ”¯æŒå¯å˜è¾“å…¥é•¿åº¦

### å“ˆå¸Œå‡½æ•°

```typescript
// Poseidon å“ˆå¸Œå‡½æ•°
function poseidon(inputs: bigint[]): bigint {
  // ä½¿ç”¨ Poseidon ç½®æ¢å‡½æ•°
  // è¿”å›å•ä¸ªå“ˆå¸Œå€¼
}

// ç¤ºä¾‹
const hash = poseidon([
  BigInt(1),
  BigInt(2),
  BigInt(3)
]);
console.log("å“ˆå¸Œ:", hash);
```

### åœ¨ MACI ä¸­çš„åº”ç”¨

**1. æ¶ˆæ¯å“ˆå¸Œ**

```typescript
// è®¡ç®—å‘½ä»¤çš„å“ˆå¸Œç”¨äºç­¾å
function hashCommand(command: Command): bigint {
  return poseidon([
    command.nonce,
    command.stateIndex,
    command.voteOptionIndex,
    command.newVoteWeight,
    command.newPubKey[0],
    command.newPubKey[1],
    command.salt
  ]);
}
```

**2. Merkle Tree**

```typescript
// è®¡ç®— Merkle Tree èŠ‚ç‚¹å“ˆå¸Œ
function hashLeaf(leaf: StateLeaf): bigint {
  return poseidon([
    leaf.pubKey[0],
    leaf.pubKey[1],
    leaf.voiceCreditBalance,
    leaf.voteOptionTreeRoot,
    leaf.nonce
  ]);
}

function hashNode(left: bigint, right: bigint): bigint {
  return poseidon([left, right]);
}
```

**3. åŠ å¯†**

```typescript
// Poseidon åŠ å¯†ï¼ˆåŸºäº Sponge æ„é€ ï¼‰
function poseidonEncrypt(
  plaintext: bigint[],
  key: bigint,
  nonce: bigint
): bigint[] {
  // ä½¿ç”¨ Poseidon ä½œä¸ºæµå¯†ç 
  // ç”Ÿæˆå¯†é’¥æµå¹¶å¼‚æˆ–æ˜æ–‡
}
```

## ECDH å¯†é’¥äº¤æ¢

ECDHï¼ˆElliptic Curve Diffie-Hellmanï¼‰ç”¨äºç”Ÿæˆå…±äº«å¯†é’¥ã€‚

### å·¥ä½œåŸç†

```mermaid
sequenceDiagram
    participant Alice as æŠ•ç¥¨è€… Alice
    participant Bob as Coordinator Bob
    Note over Alice: ç§é’¥ a, å…¬é’¥ A = a*G
    Note over Bob: ç§é’¥ b, å…¬é’¥ B = b*G
    Alice->>Bob: å‘é€å…¬é’¥ A
    Bob->>Alice: å‘é€å…¬é’¥ B
    Note over Alice: è®¡ç®— S = a*B
    Note over Bob: è®¡ç®— S = b*A
    Note over Alice,Bob: å…±äº«å¯†é’¥ S ç›¸åŒï¼<br/>å› ä¸º a*B = a*(b*G) = (a*b)*G = b*(a*G) = b*A
```

### å…±äº«å¯†é’¥ç”Ÿæˆ

```typescript
// ç”Ÿæˆ ECDH å…±äº«å¯†é’¥
function genEcdhSharedKey(
  privateKey: bigint,
  publicKey: Point
): bigint {
  // è®¡ç®— sharedPoint = privateKey * publicKey
  const sharedPoint = scalarMult(privateKey, publicKey);
  
  // ä½¿ç”¨ x åæ ‡ä½œä¸ºå…±äº«å¯†é’¥
  return sharedPoint[0];
}

// ç¤ºä¾‹ï¼šæŠ•ç¥¨è€…å’Œ Coordinator ç”Ÿæˆç›¸åŒçš„å…±äº«å¯†é’¥

// æŠ•ç¥¨è€…ä¾§
const voterPrivKey = BigInt("111");
const voterPubKey = genPublicKey(voterPrivKey);

// Coordinator ä¾§
const coordPrivKey = BigInt("222");
const coordPubKey = genPublicKey(coordPrivKey);

// æŠ•ç¥¨è€…è®¡ç®—å…±äº«å¯†é’¥
const sharedKey1 = genEcdhSharedKey(voterPrivKey, coordPubKey);

// Coordinator è®¡ç®—å…±äº«å¯†é’¥
const sharedKey2 = genEcdhSharedKey(coordPrivKey, voterPubKey);

console.log(sharedKey1 === sharedKey2);  // true
```

### å¯†é’¥æ´¾ç”Ÿ

ä»å…±äº«å¯†é’¥æ´¾ç”ŸåŠ å¯†å¯†é’¥ï¼š

```typescript
function deriveEncryptionKey(sharedKey: bigint, nonce: bigint): bigint[] {
  // ä½¿ç”¨ Poseidon æ´¾ç”Ÿå¤šä¸ªå­å¯†é’¥
  const keys = [];
  for (let i = 0; i < 10; i++) {
    keys.push(poseidon([sharedKey, nonce, BigInt(i)]));
  }
  return keys;
}
```

## æ¶ˆæ¯åŠ å¯†

MACI ä½¿ç”¨åŸºäº ECDH å’Œ Poseidon çš„åŠ å¯†æ–¹æ¡ˆã€‚

### åŠ å¯†è¿‡ç¨‹

```mermaid
graph TD
    A[æ˜æ–‡ Command] --> B[ECDH å…±äº«å¯†é’¥]
    B --> C[æ´¾ç”ŸåŠ å¯†å¯†é’¥]
    C --> D[Poseidon åŠ å¯†]
    D --> E[å¯†æ–‡]
    F[æŠ•ç¥¨è€…ç§é’¥] --> B
    G[Coordinator å…¬é’¥] --> B
    H[éšæœº Nonce] --> C
```

### åŠ å¯†å®ç°

```typescript
function encryptCommand(
  command: Command,
  voterPrivateKey: bigint,
  coordinatorPublicKey: Point
): bigint[] {
  // 1. ç”Ÿæˆ ECDH å…±äº«å¯†é’¥
  const sharedKey = genEcdhSharedKey(voterPrivateKey, coordinatorPublicKey);
  
  // 2. ç”Ÿæˆéšæœº nonce
  const nonce = genRandomNonce();
  
  // 3. æ´¾ç”ŸåŠ å¯†å¯†é’¥
  const encKeys = deriveEncryptionKey(sharedKey, nonce);
  
  // 4. æ‰“åŒ…å‘½ä»¤å­—æ®µ
  const plaintext = [
    packCommandFields(command),  // å°†å¤šä¸ªå­—æ®µæ‰“åŒ…æˆä¸€ä¸ª
    command.newPubKey[0],
    command.newPubKey[1],
    command.signature.R8[0],
    command.signature.R8[1],
    command.signature.S
  ];
  
  // 5. åŠ å¯†
  const ciphertext = poseidonEncrypt(plaintext, encKeys);
  
  return ciphertext;
}
```

### è§£å¯†è¿‡ç¨‹

```typescript
function decryptMessage(
  ciphertext: bigint[],
  coordinatorPrivateKey: bigint,
  voterPublicKey: Point
): Command {
  // 1. ç”Ÿæˆ ECDH å…±äº«å¯†é’¥ï¼ˆä¸åŠ å¯†æ—¶ç›¸åŒï¼‰
  const sharedKey = genEcdhSharedKey(coordinatorPrivateKey, voterPublicKey);
  
  // 2. æå– nonceï¼ˆåŒ…å«åœ¨å¯†æ–‡ä¸­ï¼‰
  const nonce = extractNonce(ciphertext);
  
  // 3. æ´¾ç”ŸåŠ å¯†å¯†é’¥ï¼ˆä¸åŠ å¯†æ—¶ç›¸åŒï¼‰
  const encKeys = deriveEncryptionKey(sharedKey, nonce);
  
  // 4. è§£å¯†
  const plaintext = poseidonDecrypt(ciphertext, encKeys);
  
  // 5. è§£åŒ…å‘½ä»¤
  const command = unpackCommand(plaintext);
  
  return command;
}
```

### æ¶ˆæ¯æ‰“åŒ…

ä¸ºäº†æé«˜æ•ˆç‡ï¼Œå¤šä¸ªå­—æ®µè¢«æ‰“åŒ…æˆä¸€ä¸ªå¤§æ•´æ•°ï¼š

```typescript
function packCommandFields(command: Command): bigint {
  // å°†å¤šä¸ªå°å­—æ®µæ‰“åŒ…æˆä¸€ä¸ªå¤§æ•´æ•°
  // nonce (8 bits) | stateIdx (24 bits) | voIdx (8 bits) | 
  // newVotes (24 bits) | salt (remaining bits)
  
  let packed = BigInt(0);
  packed |= (command.nonce & 0xFF);
  packed |= (command.stateIndex & 0xFFFFFF) << 8;
  packed |= (command.voteOptionIndex & 0xFF) << 32;
  packed |= (command.newVoteWeight & 0xFFFFFF) << 40;
  packed |= command.salt << 64;
  
  return packed;
}

function unpackCommandFields(packed: bigint): {
  nonce: bigint;
  stateIndex: bigint;
  voteOptionIndex: bigint;
  newVoteWeight: bigint;
  salt: bigint;
} {
  return {
    nonce: packed & BigInt(0xFF),
    stateIndex: (packed >> BigInt(8)) & BigInt(0xFFFFFF),
    voteOptionIndex: (packed >> BigInt(32)) & BigInt(0xFF),
    newVoteWeight: (packed >> BigInt(40)) & BigInt(0xFFFFFF),
    salt: packed >> BigInt(64)
  };
}
```

## å®Œæ•´çš„æŠ•ç¥¨æ¶ˆæ¯æµç¨‹

å°†æ‰€æœ‰å¯†ç å­¦ç»„ä»¶æ•´åˆåœ¨ä¸€èµ·ï¼š

```typescript
// æŠ•ç¥¨è€…ç«¯ï¼šåˆ›å»ºå’ŒåŠ å¯†æŠ•ç¥¨æ¶ˆæ¯
async function createVoteMessage(
  voterKeypair: Keypair,
  coordinatorPubKey: Point,
  voteOptions: { idx: number; weight: number }[]
): Promise<Message> {
  // 1. åˆ›å»ºå‘½ä»¤
  const command: Command = {
    nonce: getCurrentNonce(),
    stateIndex: getStateIndex(),
    voteOptionIndex: voteOptions[0].idx,
    newVoteWeight: voteOptions[0].weight,
    newPubKey: voterKeypair.publicKey,
    salt: genRandomSalt()
  };
  
  // 2. è®¡ç®—å‘½ä»¤å“ˆå¸Œ
  const commandHash = hashCommand(command);
  
  // 3. ç­¾å
  const signature = sign(voterKeypair.privateKey, commandHash);
  command.signature = signature;
  
  // 4. åŠ å¯†
  const encryptedData = encryptCommand(
    command,
    voterKeypair.privateKey,
    coordinatorPubKey
  );
  
  // 5. æ„é€ æ¶ˆæ¯
  return {
    msgType: BigInt(1),  // æŠ•ç¥¨æ¶ˆæ¯
    data: encryptedData
  };
}

// Coordinator ç«¯ï¼šè§£å¯†å’ŒéªŒè¯æ¶ˆæ¯
async function processMessage(
  message: Message,
  coordinatorPrivKey: bigint
): Promise<Command | null> {
  // 1. ä»æ¶ˆæ¯ä¸­æå–æŠ•ç¥¨è€…å…¬é’¥ï¼ˆéœ€è¦ä»çŠ¶æ€æ ‘æŸ¥è¯¢ï¼‰
  const voterPubKey = getVoterPublicKey(message);
  
  // 2. è§£å¯†
  const command = decryptMessage(
    message.data,
    coordinatorPrivKey,
    voterPubKey
  );
  
  // 3. éªŒè¯ç­¾å
  const commandHash = hashCommand(command);
  const isValid = verifySignature(commandHash, command.signature, voterPubKey);
  
  if (!isValid) {
    console.log("ç­¾åéªŒè¯å¤±è´¥");
    return null;
  }
  
  // 4. éªŒè¯ Nonce
  const currentNonce = getCurrentNonce(command.stateIndex);
  if (command.nonce !== currentNonce) {
    console.log("Nonce ä¸åŒ¹é…");
    return null;
  }
  
  // 5. è¿”å›æœ‰æ•ˆå‘½ä»¤
  return command;
}
```

## å®‰å…¨æ€§åˆ†æ

### ç­¾åå®‰å…¨æ€§

- **é˜²ä¼ªé€ **ï¼šEdDSA ç­¾ååŸºäºç¦»æ•£å¯¹æ•°é—®é¢˜ï¼Œè®¡ç®—ä¸Šä¸å¯ä¼ªé€ 
- **é˜²é‡æ”¾**ï¼šNonce æœºåˆ¶é˜²æ­¢é‡æ”¾æ”»å‡»
- **å®Œæ•´æ€§**ï¼šä»»ä½•æ¶ˆæ¯ä¿®æ”¹éƒ½ä¼šå¯¼è‡´ç­¾åéªŒè¯å¤±è´¥

### åŠ å¯†å®‰å…¨æ€§

- **æœºå¯†æ€§**ï¼šåªæœ‰æŒæœ‰ Coordinator ç§é’¥çš„äººèƒ½è§£å¯†
- **å‰å‘å®‰å…¨æ€§**ï¼šæ¯æ¡æ¶ˆæ¯ä½¿ç”¨ä¸åŒçš„ nonce
- **ä¾§ä¿¡é“æŠµæŠ—**ï¼šPoseidon åœ¨ ZK ç”µè·¯ä¸­å®ç°ï¼Œé¿å…æ—¶åºæ”»å‡»

### ZK å‹å¥½æ€§

æ‰€æœ‰å¯†ç å­¦åŸè¯­éƒ½åœ¨ ZK ç”µè·¯ä¸­é«˜æ•ˆï¼š

```
æ“ä½œ              çº¦æŸæ•°é‡ï¼ˆè¿‘ä¼¼ï¼‰
---------------------------------
Poseidon å“ˆå¸Œ     ~150 constraints
EdDSA éªŒè¯        ~2500 constraints
ECDH             ~2500 constraints
ç‚¹åŠ æ³•            ~8 constraints
```

## ä¸‹ä¸€æ­¥

å®Œæˆåï¼Œæ‚¨å¯ä»¥äº†è§£äº† MACI çš„å¯†ç å­¦æœºåˆ¶ï¼Œæ¥ä¸‹æ¥å¯ä»¥å­¦ä¹ ï¼š

- ğŸ“¨ [æ¶ˆæ¯æµç¨‹](/docs/protocol/message-flow) - äº†è§£æ¶ˆæ¯å¦‚ä½•åœ¨ç³»ç»Ÿä¸­æµåŠ¨
- [éšç§ä¿æŠ¤](/docs/protocol/privacy-protection) - æ¢ç´¢éšç§ä¿æŠ¤çš„å®ç°ç»†èŠ‚
- ğŸ—ï¸ [åˆçº¦è®¾è®¡](/docs/contracts/architecture) - äº†è§£åˆçº¦å¦‚ä½•ä½¿ç”¨è¿™äº›å¯†ç å­¦åŸè¯­
