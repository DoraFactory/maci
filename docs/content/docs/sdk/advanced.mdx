# é«˜çº§åŠŸèƒ½

æ¢ç´¢ MACI SDK çš„é«˜çº§åŠŸèƒ½å’Œæœ€ä½³å®è·µã€‚

## äº¤æ˜“ç›‘æ§

### ç›‘å¬äº¤æ˜“çŠ¶æ€

```typescript
async function monitorTransaction(
  client: MaciClient,
  txHash: string
): Promise<void> {
  console.log(`ç›‘æ§äº¤æ˜“: ${txHash}`);
  
  let confirmed = false;
  let attempts = 0;
  const maxAttempts = 30;
  
  while (!confirmed && attempts < maxAttempts) {
    try {
      const tx = await client.indexer.getTransactionByHash(txHash);
      
      if (tx.success) {
        console.log('âœ… äº¤æ˜“æˆåŠŸç¡®è®¤');
        console.log(`- åŒºå—é«˜åº¦: ${tx.height}`);
        console.log(`- Gas ä½¿ç”¨: ${tx.gasUsed}`);
        confirmed = true;
      } else {
        console.log('âŒ äº¤æ˜“å¤±è´¥');
        break;
      }
    } catch (error) {
      console.log(`ç­‰å¾…ç¡®è®¤ (${attempts + 1}/${maxAttempts})...`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      attempts++;
    }
  }
  
  if (!confirmed && attempts >= maxAttempts) {
    console.log('âš ï¸  äº¤æ˜“ç¡®è®¤è¶…æ—¶');
  }
}
```

### äº¤æ˜“é‡è¯•æœºåˆ¶

```typescript
async function retryTransaction<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      console.log(`å°è¯• ${i + 1}/${maxRetries} å¤±è´¥:`, error.message);
      
      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
      } else {
        throw error;
      }
    }
  }
  
  throw new Error('é‡è¯•æ¬¡æ•°å·²ç”¨å°½');
}

// ä½¿ç”¨
const round = await retryTransaction(() =>
  // æŸ¥è¯¢ Operator
  const operators = await client.indexer.getOperators();
  const operator = operators.filter(op => op.status === 'Active')[0];
  
  // åˆ›å»º AMACI Round
  await client.createAMaciRound({
    operator: operator.address,
    /* å…¶ä»–å‚æ•° */
  })
);
```

## æ‰¹é‡æ“ä½œ

### æ‰¹é‡æŸ¥è¯¢ Rounds

```typescript
async function batchGetRounds(
  client: MaciClient,
  contractAddresses: string[]
): Promise<Round[]> {
  const promises = contractAddresses.map(addr =>
    client.getRoundInfo({ contractAddress: addr }).catch(error => {
      console.error(`è·å– ${addr} å¤±è´¥:`, error.message);
      return null;
    })
  );
  
  const results = await Promise.all(promises);
  return results.filter(r => r !== null) as Round[];
}

// ä½¿ç”¨
const addresses = ['dora1...', 'dora2...', 'dora3...'];
const rounds = await batchGetRounds(client, addresses);
```

### æ‰¹é‡æŠ•ç¥¨å¤„ç†

```typescript
async function batchVote(
  client: MaciClient,
  wallet: any,
  address: string,
  rounds: Array<{
    contractAddress: string;
    options: { idx: number; vc: number }[];
  }>
): Promise<void> {
  for (const round of rounds) {
    try {
      console.log(`æŠ•ç¥¨: ${round.contractAddress}`);
      
      // å®Œæ•´çš„æŠ•ç¥¨æµç¨‹
      await completeVotingProcess(
        client,
        wallet,
        address,
        round.contractAddress,
        round.options
      );
      
      console.log('âœ… æˆåŠŸ');
    } catch (error) {
      console.error('âŒ å¤±è´¥:', error.message);
    }
  }
}
```

## è‡ªå®šä¹‰ç½‘ç»œé…ç½®

### è¿æ¥åˆ°è‡ªå®šä¹‰ç½‘ç»œ

```typescript
import { MaciClient } from '@dorafactory/maci-sdk';

const customClient = new MaciClient({
  network: 'testnet',  // åŸºç¡€é…ç½®
  rpcEndpoint: 'https://custom-rpc.example.com',
  chainId: 'custom-chain-1',
  gasPrice: '0.025udora',
  registryAddress: 'dora1customregistry...'
});
```

### åŠ¨æ€ç½‘ç»œåˆ‡æ¢

```typescript
class MultiNetworkClient {
  private clients: Map<string, MaciClient> = new Map();
  
  getClient(network: 'mainnet' | 'testnet' | 'local'): MaciClient {
    if (!this.clients.has(network)) {
      this.clients.set(network, new MaciClient({ network }));
    }
    return this.clients.get(network)!;
  }
  
  async getRoundOnAnyNetwork(contractAddress: string) {
    for (const network of ['mainnet', 'testnet', 'local'] as const) {
      try {
        const client = this.getClient(network);
        const round = await client.getRoundInfo({ contractAddress });
        return { network, round };
      } catch (error) {
        continue;
      }
    }
    throw new Error('Round åœ¨ä»»ä½•ç½‘ç»œä¸Šéƒ½æ‰¾ä¸åˆ°');
  }
}
```

## Gas ä¼˜åŒ–

### ä¼°ç®— Gas

```typescript
async function estimateGas(
  client: MaciClient,
  operation: 'signup' | 'vote' | 'createRound'
): Promise<number> {
  // åŸºäºæ“ä½œç±»å‹çš„ä¼°ç®—
  const gasEstimates = {
    signup: 200000,
    vote: 150000,
    createRound: 500000
  };
  
  return gasEstimates[operation];
}
```

### Gas ä»·æ ¼ä¼˜åŒ–

```typescript
async function optimizedTransaction<T>(
  client: MaciClient,
  txFn: () => Promise<T>,
  useGasStation: boolean = true
): Promise<T> {
  if (useGasStation) {
    // ä½¿ç”¨ Gas Stationï¼Œæ— éœ€æ”¯ä»˜ Gas
    return await txFn();
  } else {
    // è‡ªå·±æ”¯ä»˜ Gasï¼Œä½¿ç”¨ä¼˜åŒ–çš„ Gas ä»·æ ¼
    // è¿™é‡Œå¯ä»¥æ ¹æ®ç½‘ç»œæ‹¥å µæƒ…å†µåŠ¨æ€è°ƒæ•´
    return await txFn();
  }
}
```

## é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### ç»Ÿä¸€é”™è¯¯å¤„ç†

```typescript
class MaciError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message);
    this.name = 'MaciError';
  }
}

async function handleMaciOperation<T>(
  operation: () => Promise<T>
): Promise<T> {
  try {
    return await operation();
  } catch (error: any) {
    if (error.message.includes('insufficient funds')) {
      throw new MaciError(
        'ä½™é¢ä¸è¶³',
        'INSUFFICIENT_FUNDS',
        error
      );
    } else if (error.message.includes('not in voting period')) {
      throw new MaciError(
        'ä¸åœ¨æŠ•ç¥¨æœŸå†…',
        'NOT_IN_VOTING_PERIOD',
        error
      );
    } else if (error.message.includes('already signed up')) {
      throw new MaciError(
        'å·²ç»ç­¾åˆ°è¿‡äº†',
        'ALREADY_SIGNED_UP',
        error
      );
    } else {
      throw new MaciError(
        'æ“ä½œå¤±è´¥',
        'UNKNOWN_ERROR',
        error
      );
    }
  }
}

// ä½¿ç”¨
try {
  await handleMaciOperation(() =>
    client.maci.signup({ /* å‚æ•° */ })
  );
} catch (error) {
  if (error instanceof MaciError) {
    console.error(`é”™è¯¯ [${error.code}]: ${error.message}`);
  }
}
```

## äº‹ä»¶ç›‘å¬

### ç›‘å¬ Round çŠ¶æ€å˜åŒ–

```typescript
class RoundWatcher {
  private intervals: Map<string, NodeJS.Timeout> = new Map();
  
  watch(
    client: MaciClient,
    contractAddress: string,
    callback: (status: string) => void,
    interval: number = 10000
  ): void {
    let lastStatus: string | null = null;
    
    const checkStatus = async () => {
      try {
        const round = await client.getRoundInfo({ contractAddress });
        
        if (round.status !== lastStatus) {
          lastStatus = round.status;
          callback(round.status);
        }
      } catch (error) {
        console.error('æ£€æŸ¥çŠ¶æ€å¤±è´¥:', error);
      }
    };
    
    checkStatus();  // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
    
    const timer = setInterval(checkStatus, interval);
    this.intervals.set(contractAddress, timer);
  }
  
  unwatch(contractAddress: string): void {
    const timer = this.intervals.get(contractAddress);
    if (timer) {
      clearInterval(timer);
      this.intervals.delete(contractAddress);
    }
  }
  
  unwatchAll(): void {
    for (const timer of this.intervals.values()) {
      clearInterval(timer);
    }
    this.intervals.clear();
  }
}

// ä½¿ç”¨
const watcher = new RoundWatcher();

watcher.watch(client, 'dora1contract...', (status) => {
  console.log(`Round çŠ¶æ€å˜æ›´: ${status}`);
  
  if (status === 'Tallied') {
    console.log('æŠ•ç¥¨å·²å®Œæˆï¼Œåœæ­¢ç›‘å¬');
    watcher.unwatch('dora1contract...');
  }
});
```

## å·¥å…·å‡½æ•°

### æ—¶é—´è½¬æ¢

```typescript
// Unix æ—¶é—´æˆ³è½¬ Date
function timestampToDate(timestamp: number): Date {
  return new Date(timestamp * 1000);
}

// Date è½¬ Unix æ—¶é—´æˆ³
function dateToTimestamp(date: Date): number {
  return Math.floor(date.getTime() / 1000);
}

// æ ¼å¼åŒ–æŠ•ç¥¨æ—¶é—´
function formatVotingTime(votingTime: VotingTime): string {
  const start = timestampToDate(votingTime.startTime);
  const end = timestampToDate(votingTime.endTime);
  
  return `${start.toLocaleString()} - ${end.toLocaleString()}`;
}
```

### æŠ•ç¥¨æƒé‡è®¡ç®—

```typescript
// è®¡ç®— QV æ¨¡å¼ä¸‹çš„æœ€å¤§ç¥¨æ•°
function calculateMaxVotes(voiceCredits: number, isQV: boolean): number {
  if (isQV) {
    return Math.floor(Math.sqrt(voiceCredits));
  } else {
    return voiceCredits;
  }
}

// è®¡ç®—æŠ•ç¥¨æ¶ˆè€—
function calculateVoteCost(
  votes: { idx: number; vc: number }[],
  isQV: boolean
): number {
  return votes.reduce((sum, vote) => {
    return sum + (isQV ? vote.vc * vote.vc : vote.vc);
  }, 0);
}

// éªŒè¯æŠ•ç¥¨æ˜¯å¦åˆæ³•
function validateVotes(
  votes: { idx: number; vc: number }[],
  voiceCredits: number,
  isQV: boolean
): { valid: boolean; error?: string } {
  const cost = calculateVoteCost(votes, isQV);
  
  if (cost > voiceCredits) {
    return {
      valid: false,
      error: `æŠ•ç¥¨æ¶ˆè€— (${cost}) è¶…è¿‡å¯ç”¨é¢åº¦ (${voiceCredits})`
    };
  }
  
  return { valid: true };
}
```

## æ€§èƒ½ä¼˜åŒ–

### è¯·æ±‚å»é‡

```typescript
class RequestDeduplicator {
  private pending: Map<string, Promise<any>> = new Map();
  
  async deduplicate<T>(
    key: string,
    fn: () => Promise<T>
  ): Promise<T> {
    if (this.pending.has(key)) {
      console.log(`ä½¿ç”¨è¿›è¡Œä¸­çš„è¯·æ±‚: ${key}`);
      return this.pending.get(key);
    }
    
    const promise = fn().finally(() => {
      this.pending.delete(key);
    });
    
    this.pending.set(key, promise);
    return promise;
  }
}

const dedup = new RequestDeduplicator();

// å³ä½¿å¹¶å‘è°ƒç”¨å¤šæ¬¡ï¼Œä¹Ÿåªä¼šå‘é€ä¸€æ¬¡è¯·æ±‚
const [round1, round2, round3] = await Promise.all([
  dedup.deduplicate('round:dora1...', () => client.getRoundById('dora1...')),
  dedup.deduplicate('round:dora1...', () => client.getRoundById('dora1...')),
  dedup.deduplicate('round:dora1...', () => client.getRoundById('dora1...'))
]);
```

## ä¸‹ä¸€æ­¥

æ¢ç´¢äº†é«˜çº§åŠŸèƒ½åï¼Œæ‚¨å¯ä»¥ï¼š

- ğŸ’¡ [æŸ¥çœ‹å®Œæ•´ç¤ºä¾‹](/docs/examples/basic-voting) - å­¦ä¹ å®é™…åº”ç”¨
- ğŸ“– [å›åˆ° SDK é¦–é¡µ](/docs/sdk/installation) - æŸ¥çœ‹æ‰€æœ‰ SDK æ–‡æ¡£
- ğŸš€ [å¿«é€Ÿå¼€å§‹](/docs/introduction/quick-start) - å¿«é€Ÿä¸Šæ‰‹ MACI
