# AMACI åˆçº¦

AMACIï¼ˆAnonymous MACIï¼‰åˆçº¦æ˜¯æ¯ä¸ªæŠ•ç¥¨è½®æ¬¡çš„æ ¸å¿ƒï¼Œå¤„ç†ç”¨æˆ·ç­¾åˆ°ã€æŠ•ç¥¨æ¶ˆæ¯å­˜å‚¨ã€è¯æ˜éªŒè¯å’Œç»“æœå‘å¸ƒã€‚

## æ ¸å¿ƒåŠŸèƒ½

AMACI åˆçº¦æä¾›å››ä¸ªä¸»è¦åŠŸèƒ½ï¼š

```mermaid
graph TD
    A[AMACI åˆçº¦] --> B[ç”¨æˆ·ç­¾åˆ°]
    A --> C[æŠ•ç¥¨æ¶ˆæ¯]
    A --> D[æ¶ˆæ¯å¤„ç†]
    A --> E[ç»“æœç»Ÿè®¡]
    B --> B1[éªŒè¯ç™½åå•]
    B --> B2[åˆ†é…çŠ¶æ€ç´¢å¼•]
    C --> C1[æ¥æ”¶åŠ å¯†æ¶ˆæ¯]
    C --> C2[å­˜å‚¨åˆ°é˜Ÿåˆ—]
    D --> D1[éªŒè¯ PM è¯æ˜]
    D --> D2[æ›´æ–°çŠ¶æ€æ ¹]
    E --> E1[éªŒè¯ Tally è¯æ˜]
    E --> E2[å‘å¸ƒç»“æœ]
```

## 1. ç”¨æˆ·ç­¾åˆ°ï¼ˆSignupï¼‰

ç”¨æˆ·éœ€è¦å…ˆç­¾åˆ°æ‰èƒ½å‚ä¸æŠ•ç¥¨ã€‚

### Signup æ¶ˆæ¯

```rust
ExecuteMsg::Signup {
    pubkey: PubKey,                    // ç”¨æˆ·å…¬é’¥
    amount: Option<Uint128>,           // æŠ•ç¥¨æƒé‡ï¼ˆOracle æ¨¡å¼ï¼‰
    signature: Option<String>,         // Oracle ç­¾å
    data: Option<SignupDataDora>,      // é¢å¤–æ•°æ®
}
```

### ç­¾åˆ°æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Oracle as Oracle æœåŠ¡
    participant AMACI as AMACI åˆçº¦
    participant Storage as çŠ¶æ€æ ‘
    User->>Oracle: 1. è¯·æ±‚è¯ä¹¦
    Oracle->>Oracle: éªŒè¯ç™½åå•èµ„æ ¼
    Oracle-->>User: è¿”å› (amount, signature)
    User->>AMACI: 2. Signup(pubkey, amount, signature)
    AMACI->>AMACI: 3. éªŒè¯ç­¾å
    alt ç­¾åæ— æ•ˆ
        AMACI-->>User: é”™è¯¯ï¼šç­¾åéªŒè¯å¤±è´¥
    end
    AMACI->>AMACI: 4. æ£€æŸ¥æŠ•ç¥¨æœŸ
    alt ä¸åœ¨æŠ•ç¥¨æœŸ
        AMACI-->>User: é”™è¯¯ï¼šä¸åœ¨æŠ•ç¥¨æœŸ
    end
    AMACI->>Storage: 5. æ·»åŠ ç”¨æˆ·åˆ°çŠ¶æ€æ ‘
    AMACI->>AMACI: 6. åˆ†é…çŠ¶æ€ç´¢å¼•
    AMACI-->>User: æˆåŠŸï¼Œstate_index = N
```

### Oracle è¯ä¹¦

å¯¹äº Oracle æ¨¡å¼çš„ç™½åå•ï¼Œç”¨æˆ·éœ€è¦å…ˆè·å–è¯ä¹¦ï¼š

```typescript
// 1. è¯·æ±‚ Oracle è¯ä¹¦
const certificate = await client.maci.requestOracleCertificate({
  signer: wallet,
  ecosystem: 'cosmoshub',
  address: userAddress,
  contractAddress: amaciAddress,
});

// certificate åŒ…å«ï¼š
// {
//   amount: "100",  // æŠ•ç¥¨æƒé‡
//   signature: "0x..."  // Oracle ç­¾å
// }
```

### ç­¾åéªŒè¯

AMACI åˆçº¦éªŒè¯ Oracle ç­¾åï¼š

```rust
// éªŒè¯é€»è¾‘
fn verify_oracle_signature(
    pubkey: &PubKey,
    amount: Uint128,
    signature: &str,
    oracle_pubkey: &str
) -> Result<bool, ContractError> {
    // æ„é€ æ¶ˆæ¯
    let message = format!("{}{}{}", 
        pubkey.x, 
        pubkey.y, 
        amount
    );
    
    // éªŒè¯ç­¾å
    let is_valid = verify_signature(
        message,
        signature,
        oracle_pubkey
    );
    
    Ok(is_valid)
}
```

### Gas Station

AMACI æ”¯æŒ Gas Stationï¼Œè®©ç”¨æˆ·æ— éœ€æŒæœ‰åŸç”Ÿä»£å¸ï¼š

```typescript
// æ£€æŸ¥ Gas Station çŠ¶æ€
const hasFeegrant = await client.maci.hasFeegrant({
  address: userAddress,
  contractAddress: amaciAddress,
});

if (hasFeegrant) {
  // ä½¿ç”¨ Gas Station ç­¾åˆ°
  await client.maci.signup({
    // ... å‚æ•°
    gasStation: true,
  });
}
```

### çŠ¶æ€åˆå§‹åŒ–

ç­¾åˆ°æˆåŠŸåï¼Œç”¨æˆ·åœ¨çŠ¶æ€æ ‘ä¸­è·å¾—ä¸€ä¸ª Leafï¼š

```rust
// åˆå§‹çŠ¶æ€ Leaf
StateLeaf {
    pubkey: user_pubkey,           // ç”¨æˆ·å…¬é’¥
    voice_credit_balance: amount,  // æŠ•ç¥¨æƒé‡
    vote_option_tree_root: empty_root,  // ç©ºçš„æŠ•ç¥¨æ ‘
    nonce: 0,                      // åˆå§‹ Nonce
}
```

## 2. æŠ•ç¥¨æ¶ˆæ¯ï¼ˆPublishMessageï¼‰

ç”¨æˆ·æäº¤åŠ å¯†çš„æŠ•ç¥¨æ¶ˆæ¯ã€‚

### PublishMessage æ¶ˆæ¯

```rust
ExecuteMsg::PublishMessage {
    message: MessageData,
}

pub struct MessageData {
    pub data: Vec<Uint256>,  // 10 ä¸ªåŠ å¯†å­—æ®µ
}
```

### æ¶ˆæ¯æ ¼å¼

åŠ å¯†æ¶ˆæ¯åŒ…å« 10 ä¸ªå­—æ®µï¼š

```typescript
interface EncryptedMessage {
  data: [
    bigint,  // [0] packaged (nonce + stateIdx + voIdx + newVotes + salt)
    bigint,  // [1] newPubKey.x
    bigint,  // [2] newPubKey.y
    bigint,  // [3] signature.R8.x
    bigint,  // [4] signature.R8.y
    bigint,  // [5] signature.S
    bigint,  // [6] encryption IV
    bigint,  // [7-9] ä¿ç•™/å¡«å……
  ];
}
```

### æŠ•ç¥¨æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Client as å®¢æˆ·ç«¯ SDK
    participant AMACI as AMACI åˆçº¦
    User->>Client: vote(options, weights)
    Client->>Client: 1. ç”Ÿæˆå‘½ä»¤
    Client->>Client: 2. ç­¾å
    Client->>Client: 3. åŠ å¯†
    Client->>AMACI: 4. PublishMessage
    AMACI->>AMACI: 5. éªŒè¯æŠ•ç¥¨æœŸ
    alt ä¸åœ¨æŠ•ç¥¨æœŸ
        AMACI-->>User: é”™è¯¯ï¼šæŠ•ç¥¨æœŸå·²ç»“æŸ
    end
    AMACI->>AMACI: 6. å­˜å‚¨åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    AMACI-->>User: æˆåŠŸ
    Note over User: å¯ä»¥å¤šæ¬¡æŠ•ç¥¨
    User->>Client: revote(new_options)
    Client->>AMACI: PublishMessage
    AMACI->>AMACI: å­˜å‚¨æ–°æ¶ˆæ¯
```

### æŠ•ç¥¨ç¤ºä¾‹

```typescript
// æŠ•ç¥¨
await client.maci.vote({
  signer: wallet,
  address: userAddress,
  contractAddress: amaciAddress,
  selectedOptions: [
    { idx: 0, vc: 5 },  // ç»™é€‰é¡¹ 0 æŠ• 5 ç¥¨
    { idx: 1, vc: 3 },  // ç»™é€‰é¡¹ 1 æŠ• 3 ç¥¨
  ],
  operatorCoordPubKey: [
    BigInt(coordinatorPubKeyX),
    BigInt(coordinatorPubKeyY)
  ],
  maciAccount: keypair,
  gasStation: true,
});
```

### æ¶ˆæ¯å­˜å‚¨

æ¶ˆæ¯æŒ‰é¡ºåºå­˜å‚¨åœ¨åˆçº¦ä¸­ï¼š

```rust
// æ¶ˆæ¯é˜Ÿåˆ—
pub const MESSAGES: Item<Vec<Message>> = Item::new("messages");

// æ·»åŠ æ¶ˆæ¯
fn publish_message(
    deps: DepsMut,
    message: MessageData
) -> Result<Response, ContractError> {
    let mut messages = MESSAGES.load(deps.storage)?;
    
    messages.push(Message {
        msg_type: Uint256::from(1u128),  // 1 = æŠ•ç¥¨æ¶ˆæ¯
        data: message.data,
    });
    
    MESSAGES.save(deps.storage, &messages)?;
    
    Ok(Response::new()
        .add_attribute("action", "publish_message")
        .add_attribute("message_id", messages.len().to_string()))
}
```

### å¤šæ¬¡æŠ•ç¥¨

ç”¨æˆ·å¯ä»¥å¤šæ¬¡è°ƒç”¨ PublishMessageï¼Œåé¢çš„æ¶ˆæ¯ä¼šè¦†ç›–å‰é¢çš„ï¼š

```typescript
// ç¬¬ä¸€æ¬¡æŠ•ç¥¨
await vote({ options: [{ idx: 0, vc: 5 }], nonce: 0 });

// æ”¹å˜ä¸»æ„ï¼Œé‡æ–°æŠ•ç¥¨
await vote({ options: [{ idx: 1, vc: 5 }], nonce: 1 });

// å†æ¬¡æ”¹å˜ä¸»æ„
await vote({ options: [{ idx: 2, vc: 5 }], nonce: 2 });

// å¤„ç†æ—¶ï¼Œåªæœ‰æœ€åä¸€æ¬¡æŠ•ç¥¨ï¼ˆé€‰é¡¹ 2ï¼‰æœ‰æ•ˆ
```

## 3. æ¶ˆæ¯å¤„ç†ï¼ˆProcessMessagesï¼‰

Coordinator æäº¤é›¶çŸ¥è¯†è¯æ˜æ¥å¤„ç†æ¶ˆæ¯ã€‚

### ProcessMessages æ¶ˆæ¯

```rust
ExecuteMsg::ProcessMessages {
    new_state_commitment: Uint256,     // æ–°çŠ¶æ€æ ¹
    groth16_proof: Groth16ProofType,   // Groth16 è¯æ˜
}
```

### å¤„ç†æµç¨‹

```mermaid
sequenceDiagram
    participant Coord as Coordinator
    participant AMACI as AMACI åˆçº¦
    participant Circuit as éªŒè¯å™¨
    Note over Coord: æŠ•ç¥¨æœŸç»“æŸ
    Coord->>AMACI: 1. ä¸‹è½½æ¶ˆæ¯
    AMACI-->>Coord: è¿”å›åŠ å¯†æ¶ˆæ¯åˆ—è¡¨
    Coord->>Coord: 2. è§£å¯†æ‰€æœ‰æ¶ˆæ¯
    Coord->>Coord: 3. éªŒè¯ç­¾å
    Coord->>Coord: 4. æŒ‰ Nonce å¤„ç†
    Coord->>Coord: 5. æ›´æ–°çŠ¶æ€æ ‘
    Coord->>Coord: 6. ç”Ÿæˆ ZK è¯æ˜
    Coord->>AMACI: 7. ProcessMessages(new_root, proof)
    AMACI->>Circuit: 8. éªŒè¯è¯æ˜
    alt è¯æ˜æ— æ•ˆ
        Circuit-->>AMACI: éªŒè¯å¤±è´¥
        AMACI-->>Coord: é”™è¯¯ï¼šè¯æ˜æ— æ•ˆ
    end
    Circuit-->>AMACI: éªŒè¯æˆåŠŸ
    AMACI->>AMACI: 9. æ›´æ–°çŠ¶æ€æ ¹
    AMACI-->>Coord: æˆåŠŸ
```

### è¯æ˜éªŒè¯

```rust
fn process_messages(
    deps: DepsMut,
    new_state_commitment: Uint256,
    proof: Groth16ProofType
) -> Result<Response, ContractError> {
    // 1. æ£€æŸ¥çŠ¶æ€
    let round_info = ROUND_INFO.load(deps.storage)?;
    if round_info.status != RoundStatus::Processing {
        return Err(ContractError::InvalidRoundStatus {});
    }
    
    // 2. æ„é€ å…¬å¼€è¾“å…¥
    let public_inputs = vec![
        coordinator_pub_key_x,
        coordinator_pub_key_y,
        message_root,
        current_state_root,
        new_state_commitment,
        // ... å…¶ä»–å…¬å¼€è¾“å…¥
    ];
    
    // 3. éªŒè¯ Groth16 è¯æ˜
    let is_valid = verify_groth16_proof(
        proof,
        public_inputs,
        verification_key
    )?;
    
    if !is_valid {
        return Err(ContractError::ProofVerificationFailed {});
    }
    
    // 4. æ›´æ–°çŠ¶æ€æ ¹
    STATE_COMMITMENT.save(deps.storage, &new_state_commitment)?;
    
    Ok(Response::new()
        .add_attribute("action", "process_messages")
        .add_attribute("new_state_root", new_state_commitment.to_string()))
}
```

## 4. ç»“æœç»Ÿè®¡ï¼ˆProcessTallyï¼‰

Coordinator æäº¤ç»Ÿè®¡è¯æ˜æ¥å‘å¸ƒç»“æœã€‚

### ProcessTally æ¶ˆæ¯

```rust
ExecuteMsg::ProcessTally {
    new_tally_commitment: Uint256,     // ç»Ÿè®¡ç»“æœæ‰¿è¯º
    groth16_proof: Groth16ProofType,   // Groth16 è¯æ˜
}
```

### ç»Ÿè®¡æµç¨‹

```mermaid
sequenceDiagram
    participant Coord as Coordinator
    participant AMACI as AMACI åˆçº¦
    participant Circuit as éªŒè¯å™¨
    Note over Coord: ProcessMessages å®Œæˆ
    Coord->>Coord: 1. éå†çŠ¶æ€æ ‘
    Coord->>Coord: 2. ç»Ÿè®¡æ¯ä¸ªé€‰é¡¹çš„ç¥¨æ•°
    Coord->>Coord: 3. ç”Ÿæˆ Tally è¯æ˜
    Coord->>AMACI: 4. ProcessTally(tally, proof)
    AMACI->>Circuit: 5. éªŒè¯è¯æ˜
    alt è¯æ˜æ— æ•ˆ
        Circuit-->>AMACI: éªŒè¯å¤±è´¥
        AMACI-->>Coord: é”™è¯¯ï¼šè¯æ˜æ— æ•ˆ
    end
    Circuit-->>AMACI: éªŒè¯æˆåŠŸ
    AMACI->>AMACI: 6. ä¿å­˜ç»Ÿè®¡ç»“æœ
    AMACI->>AMACI: 7. æ›´æ–°è½®æ¬¡çŠ¶æ€ä¸º Tallied
    AMACI-->>Coord: æˆåŠŸ
    Note over AMACI: ç»“æœå·²å…¬å¼€
```

### ç»“æœå‘å¸ƒ

```rust
fn process_tally(
    deps: DepsMut,
    new_tally_commitment: Uint256,
    proof: Groth16ProofType
) -> Result<Response, ContractError> {
    // 1. éªŒè¯è¯æ˜
    let is_valid = verify_groth16_proof(
        proof,
        public_inputs,
        tally_verification_key
    )?;
    
    if !is_valid {
        return Err(ContractError::ProofVerificationFailed {});
    }
    
    // 2. ä¿å­˜ç»Ÿè®¡ç»“æœ
    TALLY_COMMITMENT.save(deps.storage, &new_tally_commitment)?;
    
    // 3. æ›´æ–°çŠ¶æ€
    let mut round_info = ROUND_INFO.load(deps.storage)?;
    round_info.status = RoundStatus::Tallied;
    ROUND_INFO.save(deps.storage, &round_info)?;
    
    Ok(Response::new()
        .add_attribute("action", "process_tally")
        .add_attribute("tally_commitment", new_tally_commitment.to_string()))
}
```

## æŸ¥è¯¢åŠŸèƒ½

### è½®æ¬¡ä¿¡æ¯

```rust
QueryMsg::GetRoundInfo {}
```

è¿”å›ï¼š

```rust
pub struct RoundInfoResponse {
    pub round_info: RoundInfo,
    pub status: RoundStatus,
    pub coordinator_pubkey: PubKey,
    pub num_signups: u64,
    pub max_voters: Uint256,
    // ... å…¶ä»–ä¿¡æ¯
}
```

### æ¶ˆæ¯æŸ¥è¯¢

```rust
// è·å–å•æ¡æ¶ˆæ¯
QueryMsg::GetMessage { index: u64 }

// è·å–æ‰€æœ‰æ¶ˆæ¯
QueryMsg::GetMessages {}

// è·å–æ¶ˆæ¯æ•°é‡
QueryMsg::GetNumMessages {}
```

### çŠ¶æ€æŸ¥è¯¢

```rust
// è·å–çŠ¶æ€æ ¹
QueryMsg::GetStateRoot {}

// è·å–ç»Ÿè®¡ç»“æœ
QueryMsg::GetTallyResult {}

// è·å–ç­¾åˆ°æ•°é‡
QueryMsg::GetNumSignups {}
```

## åŒ¿åæ€§å¢å¼º

### å»æ´»åŒ–æ£€æµ‹

AMACI æ”¯æŒå»æ´»åŒ–æ£€æµ‹æ¥å¢å¼ºåŒ¿åæ€§ï¼š

```rust
// åˆå§‹åŒ–æ—¶é…ç½®
pre_deactivate_root: Uint256,  // å»æ´»åŒ– Merkle æ ¹
pre_deactivate_coordinator: Option<PubKey>,  // å»æ´»åŒ–åè°ƒè€…
```

### å·¥ä½œåŸç†

```mermaid
graph TD
    A[ç”¨æˆ·å…¬é’¥] --> B{åœ¨å»æ´»åŒ–æ ‘ä¸­?}
    B -->|æ˜¯| C[æ ‡è®°ä¸ºå»æ´»åŒ–]
    B -->|å¦| D[æ­£å¸¸å¤„ç†]
    C --> E[ç‰¹æ®Šå¤„ç†æˆ–æ’é™¤]
    D --> F[æ­£å¸¸ç»Ÿè®¡æŠ•ç¥¨]
```

## è½®æ¬¡çŠ¶æ€

AMACI åˆçº¦æœ‰ä»¥ä¸‹çŠ¶æ€ï¼š

```rust
pub enum RoundStatus {
    Created = 0,      // å·²åˆ›å»º
    Voting = 1,       // æŠ•ç¥¨ä¸­
    Processing = 2,   // å¤„ç†ä¸­
    Tallied = 3,      // å·²ç»Ÿè®¡
}
```

### çŠ¶æ€è½¬æ¢

```mermaid
stateDiagram-v2
    [*] --> Created: åˆçº¦å®ä¾‹åŒ–
    Created --> Voting: åˆ°è¾¾å¼€å§‹æ—¶é—´
    Voting --> Processing: æŠ•ç¥¨æœŸç»“æŸ
    Processing --> Processing: ProcessMessages å¤šæ¬¡è°ƒç”¨
    Processing --> Tallied: ProcessTally æˆåŠŸ
    Tallied --> [*]: è½®æ¬¡ç»“æŸ
```

## å®‰å…¨ç‰¹æ€§

### æ—¶é—´éªŒè¯

```rust
fn ensure_voting_period(
    env: &Env,
    voting_time: &VotingTime
) -> Result<(), ContractError> {
    let current_time = env.block.time.seconds();
    
    if current_time < voting_time.start_time {
        return Err(ContractError::VotingNotStarted {});
    }
    
    if current_time > voting_time.end_time {
        return Err(ContractError::VotingEnded {});
    }
    
    Ok(())
}
```

### æƒé™æ§åˆ¶

```rust
// åªæœ‰ Coordinator å¯ä»¥å¤„ç†æ¶ˆæ¯
fn ensure_coordinator(
    sender: &Addr,
    coordinator: &Addr
) -> Result<(), ContractError> {
    if sender != coordinator {
        return Err(ContractError::Unauthorized {});
    }
    Ok(())
}
```

### é‡å…¥ä¿æŠ¤

```rust
// ä½¿ç”¨çŠ¶æ€é”é˜²æ­¢é‡å…¥
fn process_messages_with_lock(
    deps: DepsMut,
    // ... å‚æ•°
) -> Result<Response, ContractError> {
    // æ£€æŸ¥é”
    let is_locked = PROCESSING_LOCK.may_load(deps.storage)?.unwrap_or(false);
    if is_locked {
        return Err(ContractError::AlreadyProcessing {});
    }
    
    // è®¾ç½®é”
    PROCESSING_LOCK.save(deps.storage, &true)?;
    
    // å¤„ç†é€»è¾‘
    let result = process_messages_internal(deps, ...);
    
    // é‡Šæ”¾é”
    PROCESSING_LOCK.save(deps.storage, &false)?;
    
    result
}
```

## ä¸‹ä¸€æ­¥

ç°åœ¨æ‚¨å·²ç»äº†è§£äº† AMACI åˆçº¦çš„åŠŸèƒ½ï¼Œæ¥ä¸‹æ¥å¯ä»¥ï¼š

- ğŸ”„ [å®Œæ•´å·¥ä½œæµç¨‹](/contracts/workflow) - ç†è§£ä»åˆ›å»ºåˆ°ç»“æœçš„å…¨æµç¨‹
- ğŸ’» [SDK ä½¿ç”¨æŒ‡å—](/sdk/voting-guide) - ä½¿ç”¨ SDK ä¸ AMACI äº¤äº’
- ğŸ’¡ [ç¤ºä¾‹ä»£ç ](/examples/basic-voting) - æŸ¥çœ‹å®Œæ•´çš„æŠ•ç¥¨ç¤ºä¾‹
