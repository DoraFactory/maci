# AMACI åˆçº¦

AMACIï¼ˆAnonymous MACIï¼‰åˆçº¦æ˜¯æ¯ä¸ªæŠ•ç¥¨è½®æ¬¡çš„æ ¸å¿ƒï¼Œå¤„ç†ç”¨æˆ·ç­¾åˆ°ã€æŠ•ç¥¨æ¶ˆæ¯å­˜å‚¨ã€è¯æ˜éªŒè¯å’Œç»“æœå‘å¸ƒã€‚

## æ ¸å¿ƒåŠŸèƒ½

AMACI åˆçº¦æä¾›å››ä¸ªä¸»è¦åŠŸèƒ½ï¼š

```mermaid
graph TD
    A[AMACI åˆçº¦] --> B[ç”¨æˆ·ç­¾åˆ°]
    A --> C[æŠ•ç¥¨æ¶ˆæ¯]
    A --> D[æ¶ˆæ¯å¤„ç†]
    A --> E[ç»“æœç»Ÿè®¡]
    B --> B1[éªŒè¯ç™½åå•]
    B --> B2[åˆ†é…çŠ¶æ€ç´¢å¼•]
    C --> C1[æ¥æ”¶åŠ å¯†æ¶ˆæ¯]
    C --> C2[å­˜å‚¨åˆ°é˜Ÿåˆ—]
    D --> D1[éªŒè¯ PM è¯æ˜]
    D --> D2[æ›´æ–°çŠ¶æ€æ ¹]
    E --> E1[éªŒè¯ Tally è¯æ˜]
    E --> E2[å‘å¸ƒç»“æœ]
```

## ç”¨æˆ·æ³¨å†Œæ–¹å¼

AMACI æ”¯æŒä¸‰ç§æ³¨å†Œæ–¹å¼ï¼Œç”¨æˆ·å¯æ ¹æ®éšç§éœ€æ±‚é€‰æ‹©ã€‚

## 1. Signupï¼ˆæ ‡å‡†æ³¨å†Œï¼‰

æœ€ç®€å•å¿«æ·çš„æ³¨å†Œæ–¹å¼ï¼Œé€‚åˆä¸å…³å¿ƒ Operator çŸ¥é“èº«ä»½çš„åœºæ™¯ã€‚

### Signup æ¶ˆæ¯

```rust
ExecuteMsg::Signup {
    pubkey: PubKey,                    // ç”¨æˆ·å…¬é’¥
    data: Option<SignupDataDora>,      // é¢å¤–æ•°æ®
}
```

### ç­¾åˆ°æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant AMACI as AMACI åˆçº¦
    participant Storage as çŠ¶æ€æ ‘
    User->>AMACI: 1. Signup(pubkey)
    AMACI->>AMACI: 2. æ£€æŸ¥ç™½åå•
    alt ä¸åœ¨ç™½åå•
        AMACI-->>User: é”™è¯¯ï¼šä¸åœ¨ç™½åå•
    end
    AMACI->>AMACI: 3. æ£€æŸ¥æŠ•ç¥¨æœŸ
    alt ä¸åœ¨æŠ•ç¥¨æœŸ
        AMACI-->>User: é”™è¯¯ï¼šä¸åœ¨æŠ•ç¥¨æœŸ
    end
    AMACI->>Storage: 4. æ·»åŠ ç”¨æˆ·åˆ°çŠ¶æ€æ ‘
    AMACI->>AMACI: 5. åˆ†é…çŠ¶æ€ç´¢å¼•
    AMACI-->>User: æˆåŠŸï¼Œstate_index = N
```

### Signup ä»£ç ç¤ºä¾‹

```typescript
// 1. ç”Ÿæˆ MACI å¯†é’¥å¯¹
// ä½¿ç”¨ dora åœ°å€è¡ç”Ÿ EdDSA-Poseidon å¯†é’¥å¯¹
const maciKeypair = await client.genKeypairFromSign({
  signer: wallet,
  address
});

// 2. Signupï¼ˆä»…ç™½åå•åœ°å€å¯ç”¨ï¼‰
await client.signup({
  signer: wallet,
  address: userAddress,
  contractAddress: amaciAddress,
  maciKeypair
});
```

**ç™½åå•éªŒè¯ï¼š**

åˆçº¦ä¼šéªŒè¯å‘é€è€…åœ°å€æ˜¯å¦åœ¨ç™½åå•ä¸­ï¼š
- åˆ›å»º Round æ—¶é…ç½®ç™½åå•åœ°å€åˆ—è¡¨
- åªæœ‰ç™½åå•åœ°å€å¯ä»¥ signup
- æ‰€æœ‰ç™½åå•ç”¨æˆ·è·å¾—ç›¸åŒæŠ•ç¥¨æƒé‡

```typescript
// åˆ›å»º Round æ—¶é…ç½®ç™½åå•
await client.createAMaciRound({
  // ...
  whitelist: {
    addresses: [
      'dora1abc...',
      'dora1def...',
      'dora1ghi...'
    ]
  },
  voiceCreditAmount: '100'  // æ¯ä¸ªç”¨æˆ·çš„æŠ•ç¥¨é¢åº¦
});
```

### Signup éšç§çº§åˆ«

**éšç§çº§åˆ«ï¼š** ï¼ˆä½ï¼‰

**Operator å¯ä»¥çœ‹åˆ°ï¼š**
- é’±åŒ…åœ°å€ï¼ˆé€šè¿‡é“¾ä¸Š signup äº¤æ˜“ï¼‰
- MACI å…¬é’¥
- State Index
- æŠ•ç¥¨å†…å®¹ï¼ˆè§£å¯†åï¼‰

**é£é™©ï¼š**
- Operator å¯ä»¥å®Œæ•´å…³è”ï¼šé’±åŒ…åœ°å€ â†’ å…¬é’¥ â†’ State Index â†’ æŠ•ç¥¨å†…å®¹
- å¯èƒ½è¿›è¡Œé’ˆå¯¹æ€§çš„è´¿èµ‚æˆ–æŠ¥å¤

**é€‚ç”¨åœºæ™¯ï¼š**
- ä¸å…³å¿ƒ Operator çŸ¥é“èº«ä»½
- å¿«é€Ÿç®€å•çš„æŠ•ç¥¨
- å¯ä¿¡çš„ Operator

---

## 2. Add-new-keyï¼ˆåŠ¨æ€æ¢ keyï¼‰

ä½¿ç”¨é›¶çŸ¥è¯†è¯æ˜åˆ›å»ºåŒ¿åèº«ä»½ï¼ŒOperator æ— æ³•å…³è”åˆ°åŸå§‹ç”¨æˆ·ã€‚

### Add-new-key æ¶ˆæ¯

```rust
ExecuteMsg::AddNewKey {
    pubkey: PubKey,              // æ–°çš„ç”¨æˆ·å…¬é’¥
    nullifier: Uint256,          // é˜²é‡æ”¾æ ‡è¯†
    d: [Uint256; 4],            // [d1[0], d1[1], d2[0], d2[1]]
    groth16_proof: Groth16ProofType,  // ZK è¯æ˜
}
```

### å®Œæ•´æµç¨‹

**è€ç”¨æˆ· Deactivate**

```typescript
// è€ç”¨æˆ·æäº¤ deactivate æ¶ˆæ¯
await client.deactivate({
  signer: oldWallet,
  address: oldAddress,
  contractAddress,
  maciKeypair: oldKeypair
});

// è¿™ä¼šç”Ÿæˆä¸€ä¸ªç‰¹æ®Šçš„æŠ•ç¥¨æ¶ˆæ¯ï¼š
// - voIdx = 0
// - newVotes = 0
// - newPubKey = [0, 0]ï¼ˆè¡¨ç¤ºæœ€åä¸€æ¡æ¶ˆæ¯ï¼‰
```

**Operator å¤„ç† Deactivate**

```typescript
// Operator å¤„ç†æ‰€æœ‰ deactivate æ¶ˆæ¯
// ç”Ÿæˆ deactivate tree

// æ¯ä¸ª deactivate leaf åŒ…å«ï¼š
// [c1[0], c1[1], c2[0], c2[1], sharedKeyHash]

// Operator æäº¤ ProcessDeactivate
await contract.execute({
  process_deactivate: {
    size: deactivateMessages.length,
    new_deactivate_commitment: deactivateCommitment,
    new_deactivate_root: deactivateRoot,
    groth16_proof: processDeactivateProof
  }
});
```

**æ–°ç”¨æˆ·ç”Ÿæˆ ZK è¯æ˜**

```typescript
// ä½¿ç”¨ VoterClient ç”Ÿæˆ payload
import { VoterClient } from '@dorafactory/maci-sdk';

const voterClient = new VoterClient({
  network: 'testnet',
  secretKey: oldPrivateKeyHex  // è€ç”¨æˆ·çš„ç§é’¥
});

// è·å– deactivate æ•°æ®
const deactivates = await client.fetchAllDeactivateLogs(contractAddress);

// ç”Ÿæˆ add-new-key payload
const payload = await voterClient.buildAddNewKeyPayload({
  stateTreeDepth: 10,
  operatorPubkey: operatorPubkey,
  deactivates: deactivates,
  wasmFile,  // addNewKey.wasm
  zkeyFile   // addNewKey.zkey
});

// payload åŒ…å«ï¼š
// {
//   proof: { a, b, c },          // Groth16 è¯æ˜
//   d: [d1_0, d1_1, d2_0, d2_1], // é‡æ–°éšæœºåŒ–çš„å€¼
//   nullifier: "0x..."            // é˜²é‡æ”¾
// }
```

**æäº¤ Add-new-key**

```typescript
// ä½¿ç”¨æ–°é’±åŒ…æäº¤ï¼ˆé‡è¦ï¼ï¼‰
const newKeypair = genKeypair();

await client.addNewKey({
  signer: newWallet,      // æ–°é’±åŒ…
  contractAddress,
  d: payload.d,
  proof: payload.proof,
  nullifier: payload.nullifier,
  newMaciKeypair: newKeypair,  // æ–°çš„ MACI å¯†é’¥å¯¹
  fee: 'auto'
});
```

### åˆçº¦éªŒè¯æµç¨‹

```rust
pub fn execute_add_new_key(
    deps: DepsMut,
    env: Env,
    pubkey: PubKey,
    nullifier: Uint256,
    d: [Uint256; 4],
    groth16_proof: Groth16ProofType,
) -> Result<Response, ContractError> {
    // 1. æ£€æŸ¥æŠ•ç¥¨æœŸ
    check_voting_time(env, voting_time)?;
    
    // 2. æ£€æŸ¥ nullifier æ˜¯å¦å·²ä½¿ç”¨
    if NULLIFIERS.has(deps.storage, nullifier.to_be_bytes()) {
        return Err(ContractError::NewKeyExist {});
    }
    NULLIFIERS.save(deps.storage, nullifier.to_be_bytes(), &true)?;
    
    // 3. æ„å»ºå…¬å¼€è¾“å…¥
    let input = [
        DNODES.load(...)?,        // deactivate root
        COORDINATORHASH.load(...)?,  // operator pubkey hash
        nullifier,
        d[0], d[1], d[2], d[3]
    ];
    let input_hash = hash_256(input) % SNARK_SCALAR_FIELD;
    
    // 4. éªŒè¯ ZK è¯æ˜
    let is_valid = groth16_verify(&proof, &[input_hash])?;
    if !is_valid {
        return Err(ContractError::InvalidProof {
            step: "AddNewKey".to_string()
        });
    }
    
    // 5. åˆ›å»ºæ–° State Leafï¼ˆåŒ…å« d1, d2ï¼‰
    let state_leaf = StateLeaf {
        pub_key: pubkey,
        voice_credit_balance: voice_credit_amount,
        vote_option_tree_root: Uint256::zero(),
        nonce: Uint256::zero(),
    }.hash_new_key_state_leaf(d);
    
    // 6. åˆ†é… State Index
    let state_index = num_sign_ups;
    state_enqueue(&mut deps, state_leaf)?;
    num_sign_ups += 1;
    
    // 7. ä¿å­˜æ˜ å°„ï¼ˆå…¬é’¥ â†’ state indexï¼‰
    SIGNUPED.save(deps.storage, &pubkey_bytes, &state_index)?;
    
    Ok(Response::new()
        .add_attribute("action", "add_new_key")
        .add_attribute("state_idx", state_index.to_string()))
}
```

### ZK ç”µè·¯è¯´æ˜

Add-new-key ä½¿ç”¨ä¸“é—¨çš„ ZK ç”µè·¯éªŒè¯ç”¨æˆ·èº«ä»½ï¼š

```circom
template AddNewKey(stateTreeDepth) {
    // å…¬å¼€è¾“å…¥
    signal input deactivateRoot;      // Deactivate æ ‘æ ¹
    signal input coordPubKey[2];      // Operator å…¬é’¥
    signal input nullifier;           // é˜²é‡æ”¾
    signal input d1[2];               // é‡æ–°éšæœºåŒ–çš„å€¼
    signal input d2[2];
    
    // ç§æœ‰è¾“å…¥ï¼ˆå…³é”®ï¼ä¸å…¬å¼€ï¼‰
    signal input oldPrivateKey;       // è€ç”¨æˆ·ç§é’¥
    signal input deactivateIndex;     // åœ¨æ ‘ä¸­çš„ä½ç½®
    signal input deactivateLeaf;      // Leaf å€¼
    signal input c1[2];               // åŸå§‹åŠ å¯†å€¼
    signal input c2[2];
    signal input randomVal;           // éšæœºåŒ–ç”¨çš„éšæœºæ•°
    signal input deactivateLeafPathElements[...];  // Merkle è·¯å¾„
    
    // éªŒè¯æ­¥éª¤ï¼š
    // 1. éªŒè¯ nullifier = hash(oldPrivateKey, constant)
    // 2. è®¡ç®— sharedKeyHash = hash(ecdh(oldPrivKey, coordPubKey))
    // 3. éªŒè¯ deactivateLeaf = hash(c1, c2, sharedKeyHash)
    // 4. éªŒè¯ leaf åœ¨ deactivateRoot æ ‘ä¸­ï¼ˆä½¿ç”¨ deactivateIndex å’Œè·¯å¾„ï¼‰
    // 5. éªŒè¯ d1, d2 = rerandomize(c1, c2, randomVal, coordPubKey)
}
```

### Add-new-key éšç§çº§åˆ«

**éšç§çº§åˆ«ï¼š** ï¼ˆæœ€é«˜ï¼‰

**Operator åªèƒ½çœ‹åˆ°ï¼š**
- æ–°é’±åŒ…åœ°å€ï¼ˆå¯èƒ½æ˜¯å…¨æ–°çš„ï¼‰
- æ–° MACI å…¬é’¥
- nullifierï¼ˆåªæ˜¯ä¸ªå“ˆå¸Œï¼‰
- d1, d2ï¼ˆé‡æ–°éšæœºåŒ–çš„å€¼ï¼‰
- ZK è¯æ˜ï¼ˆå·²éªŒè¯é€šè¿‡ï¼‰

**Operator æ— æ³•ç¡®å®šï¼š**
- æ–°ç”¨æˆ·æ˜¯ deactivate æ ‘ä¸­çš„ç¬¬å‡ ä¸ª
- å¯¹åº”å“ªä¸ªé’±åŒ…åœ°å€
- ä¸å“ªä¸ªè€èº«ä»½å…³è”
- oldPrivateKey æ˜¯ä»€ä¹ˆ

**åŒ¿åé›†ï¼š**
- åŒ¿åé›†å¤§å° = deactivate æ ‘ä¸­çš„æ¡ç›®æ•°
- ä¾‹å¦‚ï¼š100 ä¸ª deactivate â†’ Operator çŸ¥é“æ˜¯"100äººä¹‹ä¸€"

---

## 3. Pre-add-new-keyï¼ˆé¢„é…ç½®æ¢ keyï¼‰

ä½¿ç”¨é¢„å…ˆé…ç½®çš„ deactivate rootï¼Œç«‹å³åˆ›å»ºåŒ¿åèº«ä»½ã€‚

### Pre-add-new-key æ¶ˆæ¯

```rust
ExecuteMsg::PreAddNewKey {
    pubkey: PubKey,              // æ–°çš„ç”¨æˆ·å…¬é’¥
    nullifier: Uint256,          // é˜²é‡æ”¾æ ‡è¯†
    d: [Uint256; 4],            // [d1[0], d1[1], d2[0], d2[1]]
    groth16_proof: Groth16ProofType,  // ZK è¯æ˜
}
```

### ä¸ Add-new-key çš„åŒºåˆ«

| ç‰¹æ€§ | Add-new-key | Pre-add-new-key |
|------|-------------|-----------------|
| Deactivate æ¥æº | æŠ•ç¥¨æœŸé—´åŠ¨æ€ç”Ÿæˆ | Round åˆ›å»ºæ—¶é¢„é…ç½® |
| Coordinator | å½“å‰ Operator | é¢„é…ç½®çš„ Coordinator |
| ç­‰å¾…æ—¶é—´ | éœ€ç­‰å¾… ProcessDeactivate | ç«‹å³å¯ç”¨ |
| çµæ´»æ€§ | é«˜ï¼ˆå®æ—¶ï¼‰ | ä¸­ï¼ˆéœ€é¢„é…ç½®ï¼‰ |

### åˆçº¦éªŒè¯å·®å¼‚

```rust
// add-new-key ä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„ root
input[0] = DNODES.load(deps.storage, ...)?;  // åŠ¨æ€
input[1] = COORDINATORHASH.load(deps.storage)?;  // å½“å‰ operator

// pre-add-new-key ä½¿ç”¨é¢„é…ç½®çš„ root
input[0] = PRE_DEACTIVATE_ROOT.load(deps.storage)?;  // é¢„é…ç½®
input[1] = PRE_DEACTIVATE_COORDINATOR_HASH.load(...)?;  // å¯èƒ½ä¸åŒ
```

### ä½¿ç”¨åœºæ™¯

**é€‚åˆåœºæ™¯ï¼š**
- Round åˆ›å»ºæ—¶å·²çŸ¥éœ€è¦åŒ¿åæŠ•ç¥¨
- é¢„å…ˆå‡†å¤‡å¥½ä¸€ç»„ deactivate æ•°æ®
- å¸Œæœ›ç”¨æˆ·ç«‹å³å¯ä»¥åŒ¿åå‚ä¸

**Round é…ç½®ç¤ºä¾‹ï¼š**

```typescript
// åˆ›å»º Round æ—¶é…ç½®
await client.createAMaciRound({
  // ... å…¶ä»–å‚æ•°
  
  // é…ç½® pre-deactivate
  preDeactivateRoot: preDeactivateData.root,
  preDeactivateCoordinator: {
    x: preCoordPubkey[0],
    y: preCoordPubkey[1]
  }
});
```

### Pre-add-new-key éšç§çº§åˆ«

**éšç§çº§åˆ«ï¼š** ï¼ˆæœ€é«˜ï¼‰

ä¸ add-new-key ç›¸åŒçš„éšç§ä¿æŠ¤ï¼Œä½†æ— éœ€ç­‰å¾…ã€‚

---

## 4. Process Deactivateï¼ˆAMACI ç‹¬æœ‰ï¼‰

Operator å¤„ç† deactivate æ¶ˆæ¯ï¼Œä¸º add-new-key ç”Ÿæˆ deactivate æ ‘ã€‚

### Process Deactivate æ¶ˆæ¯

```rust
ExecuteMsg::ProcessDeactivate {
    size: u64,                          // å¤„ç†çš„æ¶ˆæ¯æ•°é‡
    new_deactivate_commitment: Uint256, // æ–°çš„ deactivate commitment
    new_deactivate_root: Uint256,       // æ–°çš„ deactivate æ ‘æ ¹
    groth16_proof: Groth16ProofType,    // ZK è¯æ˜
}
```

### å·¥ä½œæµç¨‹

**1. æ”¶é›† Deactivate æ¶ˆæ¯**

```typescript
// ç”¨æˆ·æäº¤ deactivate
await client.deactivate({
  signer: wallet,
  contractAddress,
  maciKeypair
});

// ç”Ÿæˆçš„æ˜¯ç‰¹æ®Šçš„æŠ•ç¥¨æ¶ˆæ¯ï¼š
// {
//   nonce: current_nonce,
//   stateIdx: user_state_idx,
//   voIdx: 0,          // ç‰¹æ®Šæ ‡è®°
//   newVotes: 0,       // ç‰¹æ®Šæ ‡è®°
//   newPubKey: [0, 0], // è¡¨ç¤ºæœ€åä¸€æ¡æ¶ˆæ¯
//   signature: ...
// }
```

**2. Operator å¤„ç† Deactivate**

```typescript
// Operator è§£å¯† deactivate æ¶ˆæ¯
const deactivateCommands = deactivateMessages.map(msg => {
  const sharedKey = ecdh(operatorPrivKey, msg.encPubKey);
  const command = poseidonDecrypt(msg.data, sharedKey);
  return command;
});

// ç”Ÿæˆ deactivate tree
const deactivateLeaves = [];
for (const cmd of deactivateCommands) {
  const stateIdx = cmd.stateIdx;
  const userPubKey = stateTree.getLeaf(stateIdx).pubKey;
  
  // ç”ŸæˆåŠ å¯†çš„å»æ´»åŒ–æ ‡å¿—
  const sharedKey = ecdh(operatorPrivKey, userPubKey);
  const sharedKeyHash = poseidon(sharedKey);
  
  const randomVal = deterministicRandom(operatorPrivKey, stateIdx);
  const { c1, c2 } = encryptDeactivateFlag(
    true,  // æ ‡è®°ä¸ºå·²å»æ´»åŒ–
    operatorPubKey,
    randomVal
  );
  
  // æ„å»º leaf
  const leaf = [c1[0], c1[1], c2[0], c2[1], sharedKeyHash];
  deactivateLeaves.push(leaf);
}

// æ„å»º Merkle æ ‘
const deactivateTree = new Tree(5, stateTreeDepth + 2, 0n);
deactivateTree.initLeaves(deactivateLeaves.map(l => poseidon(l)));

const deactivateRoot = deactivateTree.root;
```

**3. ç”Ÿæˆå¹¶æäº¤è¯æ˜**

```typescript
// ç”Ÿæˆ ProcessDeactivate è¯æ˜
const { proof } = await groth16.fullProve(
  processDeactivateInput,
  wasmFile,
  zkeyFile
);

// æäº¤åˆ°åˆçº¦
await contract.execute({
  process_deactivate: {
    size: deactivateMessages.length,
    new_deactivate_commitment: deactivateCommitment,
    new_deactivate_root: deactivateRoot,
    groth16_proof: proof
  }
});
```

### Process Deactivate ç”µè·¯

```circom
template ProcessDeactivateMessages(stateTreeDepth, batchSize) {
    // å…¬å¼€è¾“å…¥
    signal input newDeactivateRoot;
    signal input coordPubKey[2];
    signal input batchStartHash;
    signal input batchEndHash;
    signal input currentDeactivateCommitment;
    signal input newDeactivateCommitment;
    
    // ç§æœ‰è¾“å…¥
    signal input coordPrivKey;               // Operator ç§é’¥
    signal input msgs[batchSize][7];         // åŠ å¯†æ¶ˆæ¯
    signal input encPubKeys[batchSize][2];   // åŠ å¯†å…¬é’¥
    signal input currentStateLeaves[batchSize][10];  // å½“å‰çŠ¶æ€
    signal input c1[batchSize][2];           // ç”Ÿæˆçš„åŠ å¯†å€¼
    signal input c2[batchSize][2];
    
    // éªŒè¯æ­¥éª¤ï¼š
    // 1. è§£å¯†æ‰€æœ‰ deactivate æ¶ˆæ¯
    // 2. éªŒè¯æ¯ä¸ªæ¶ˆæ¯çš„ç­¾å
    // 3. ä¸ºæ¯ä¸ªç”¨æˆ·ç”Ÿæˆ deactivate entry (c1, c2, hash)
    // 4. æ„å»ºæ–°çš„ deactivate tree
    // 5. éªŒè¯ newDeactivateRoot æ­£ç¡®
}
```

### åˆçº¦éªŒè¯

```rust
pub fn execute_process_deactivate(
    deps: DepsMut,
    size: u64,
    new_deactivate_commitment: Uint256,
    new_deactivate_root: Uint256,
    groth16_proof: Groth16ProofType,
) -> Result<Response, ContractError> {
    // 1. æ£€æŸ¥çŠ¶æ€
    // 2. æ„å»ºå…¬å¼€è¾“å…¥
    let input = [
        new_deactivate_root,
        coord_pubkey_hash,
        batch_start_hash,
        batch_end_hash,
        current_deactivate_commitment,
        new_deactivate_commitment,
        current_state_root
    ];
    
    // 3. éªŒè¯ ZK è¯æ˜
    let is_valid = groth16_verify(&proof, &[input_hash])?;
    if !is_valid {
        return Err(ContractError::InvalidProof {
            step: "ProcessDeactivate".to_string()
        });
    }
    
    // 4. æ›´æ–° deactivate root
    DNODES.save(deps.storage, key, &new_deactivate_root)?;
    CURRENT_DEACTIVATE_COMMITMENT.save(..., &new_deactivate_commitment)?;
    
    // 5. æ›´æ–°å¤„ç†è®¡æ•°
    PROCESSED_DMSG_COUNT.save(deps.storage, &new_count)?;
    
    Ok(Response::new())
}
```

### Process Deactivate çš„ä½œç”¨

**ä¸º Add-new-key æä¾›åŒ¿åé›†ï¼š**

```
æ²¡æœ‰ ProcessDeactivate:
â†’ æ— æ³•ä½¿ç”¨ add-new-key
â†’ åªèƒ½ç”¨ signupï¼ˆä½éšç§ï¼‰

æœ‰ ProcessDeactivate:
â†’ ç”Ÿæˆ deactivate tree
â†’ ç”¨æˆ·å¯ä»¥ä½¿ç”¨ add-new-key
â†’ åŒ¿åé›†å¤§å° = deactivate æ¶ˆæ¯æ•°é‡
```

**æ—¶æœºï¼š**
- å¯ä»¥åœ¨æŠ•ç¥¨æœŸé—´éšæ—¶å¤„ç†
- é€šå¸¸åœ¨æœ‰è¶³å¤Ÿå¤š deactivate æ¶ˆæ¯åå¤„ç†
- å»ºè®®ï¼šè‡³å°‘ 50-100 ä¸ª deactivate å†å¤„ç†ï¼ˆæ›´å¤§çš„åŒ¿åé›†ï¼‰

---

## æŠ•ç¥¨æ¶ˆæ¯ï¼ˆPublishMessageï¼‰

ç”¨æˆ·æ³¨å†Œåï¼ˆæ— è®ºä½¿ç”¨å“ªç§æ–¹å¼ï¼‰ï¼Œéƒ½å¯ä»¥æäº¤åŠ å¯†çš„æŠ•ç¥¨æ¶ˆæ¯ã€‚

### PublishMessage æ¶ˆæ¯

```rust
ExecuteMsg::PublishMessage {
    message: MessageData,
}

pub struct MessageData {
    pub data: Vec<Uint256>,  // 10 ä¸ªåŠ å¯†å­—æ®µ
}
```

### æ¶ˆæ¯æ ¼å¼

åŠ å¯†æ¶ˆæ¯åŒ…å« 10 ä¸ªå­—æ®µï¼š

```typescript
interface EncryptedMessage {
  data: [
    bigint,  // [0] packaged (nonce + stateIdx + voIdx + newVotes + salt)
    bigint,  // [1] newPubKey.x
    bigint,  // [2] newPubKey.y
    bigint,  // [3] signature.R8.x
    bigint,  // [4] signature.R8.y
    bigint,  // [5] signature.S
    bigint,  // [6] encryption IV
    bigint,  // [7-9] ä¿ç•™/å¡«å……
  ];
}
```

### æŠ•ç¥¨æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Client as å®¢æˆ·ç«¯ SDK
    participant AMACI as AMACI åˆçº¦
    User->>Client: vote(options, weights)
    Client->>Client: 1. ç”Ÿæˆå‘½ä»¤
    Client->>Client: 2. ç­¾å
    Client->>Client: 3. åŠ å¯†
    Client->>AMACI: 4. PublishMessage
    AMACI->>AMACI: 5. éªŒè¯æŠ•ç¥¨æœŸ
    alt ä¸åœ¨æŠ•ç¥¨æœŸ
        AMACI-->>User: é”™è¯¯ï¼šæŠ•ç¥¨æœŸå·²ç»“æŸ
    end
    AMACI->>AMACI: 6. å­˜å‚¨åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    AMACI-->>User: æˆåŠŸ
    Note over User: å¯ä»¥å¤šæ¬¡æŠ•ç¥¨
    User->>Client: revote(new_options)
    Client->>AMACI: PublishMessage
    AMACI->>AMACI: å­˜å‚¨æ–°æ¶ˆæ¯
```

### æŠ•ç¥¨ç¤ºä¾‹

```typescript
// è·å– Operator å…¬é’¥
const roundInfo = await client.getRoundInfo({ contractAddress: amaciAddress });

// æŠ•ç¥¨
await client.vote({
  signer: wallet,
  address: userAddress,
  contractAddress: amaciAddress,
  selectedOptions: [
    { idx: 0, vc: 5 },  // ç»™é€‰é¡¹ 0 æŠ• 5 ç¥¨
    { idx: 1, vc: 3 },  // ç»™é€‰é¡¹ 1 æŠ• 3 ç¥¨
  ],
  operatorCoordPubKey: [
    BigInt(roundInfo.coordinatorPubkeyX),
    BigInt(roundInfo.coordinatorPubkeyY)
  ],
  maciKeypair: keypair
});
```

### æ¶ˆæ¯å­˜å‚¨

æ¶ˆæ¯æŒ‰é¡ºåºå­˜å‚¨åœ¨åˆçº¦ä¸­ï¼š

```rust
// æ¶ˆæ¯é˜Ÿåˆ—
pub const MESSAGES: Item<Vec<Message>> = Item::new("messages");

// æ·»åŠ æ¶ˆæ¯
fn publish_message(
    deps: DepsMut,
    message: MessageData
) -> Result<Response, ContractError> {
    let mut messages = MESSAGES.load(deps.storage)?;
    
    messages.push(Message {
        msg_type: Uint256::from(1u128),  // 1 = æŠ•ç¥¨æ¶ˆæ¯
        data: message.data,
    });
    
    MESSAGES.save(deps.storage, &messages)?;
    
    Ok(Response::new()
        .add_attribute("action", "publish_message")
        .add_attribute("message_id", messages.len().to_string()))
}
```

### å¤šæ¬¡æŠ•ç¥¨

ç”¨æˆ·å¯ä»¥å¤šæ¬¡è°ƒç”¨ PublishMessageï¼Œåé¢çš„æ¶ˆæ¯ä¼šè¦†ç›–å‰é¢çš„ï¼š

```typescript
// ç¬¬ä¸€æ¬¡æŠ•ç¥¨
await vote({ options: [{ idx: 0, vc: 5 }], nonce: 0 });

// æ”¹å˜ä¸»æ„ï¼Œé‡æ–°æŠ•ç¥¨
await vote({ options: [{ idx: 1, vc: 5 }], nonce: 1 });

// å†æ¬¡æ”¹å˜ä¸»æ„
await vote({ options: [{ idx: 2, vc: 5 }], nonce: 2 });

// å¤„ç†æ—¶ï¼Œåªæœ‰æœ€åä¸€æ¬¡æŠ•ç¥¨ï¼ˆé€‰é¡¹ 2ï¼‰æœ‰æ•ˆ
```

---

## æ¶ˆæ¯å¤„ç†ï¼ˆProcessMessagesï¼‰

Operator æäº¤é›¶çŸ¥è¯†è¯æ˜æ¥å¤„ç†æŠ•ç¥¨æ¶ˆæ¯ã€‚

### ProcessMessages æ¶ˆæ¯

```rust
ExecuteMsg::ProcessMessages {
    new_state_commitment: Uint256,     // æ–°çŠ¶æ€æ ¹
    groth16_proof: Groth16ProofType,   // Groth16 è¯æ˜
}
```

### å¤„ç†æµç¨‹

```mermaid
sequenceDiagram
    participant Coord as Coordinator
    participant AMACI as AMACI åˆçº¦
    participant Circuit as éªŒè¯å™¨
    Note over Coord: æŠ•ç¥¨æœŸç»“æŸ
    Coord->>AMACI: 1. ä¸‹è½½æ¶ˆæ¯
    AMACI-->>Coord: è¿”å›åŠ å¯†æ¶ˆæ¯åˆ—è¡¨
    Coord->>Coord: 2. è§£å¯†æ‰€æœ‰æ¶ˆæ¯
    Coord->>Coord: 3. éªŒè¯ç­¾å
    Coord->>Coord: 4. æŒ‰ Nonce å¤„ç†
    Coord->>Coord: 5. æ›´æ–°çŠ¶æ€æ ‘
    Coord->>Coord: 6. ç”Ÿæˆ ZK è¯æ˜
    Coord->>AMACI: 7. ProcessMessages(new_root, proof)
    AMACI->>Circuit: 8. éªŒè¯è¯æ˜
    alt è¯æ˜æ— æ•ˆ
        Circuit-->>AMACI: éªŒè¯å¤±è´¥
        AMACI-->>Coord: é”™è¯¯ï¼šè¯æ˜æ— æ•ˆ
    end
    Circuit-->>AMACI: éªŒè¯æˆåŠŸ
    AMACI->>AMACI: 9. æ›´æ–°çŠ¶æ€æ ¹
    AMACI-->>Coord: æˆåŠŸ
```

### è¯æ˜éªŒè¯

```rust
fn process_messages(
    deps: DepsMut,
    new_state_commitment: Uint256,
    proof: Groth16ProofType
) -> Result<Response, ContractError> {
    // 1. æ£€æŸ¥çŠ¶æ€
    let round_info = ROUND_INFO.load(deps.storage)?;
    if round_info.status != RoundStatus::Processing {
        return Err(ContractError::InvalidRoundStatus {});
    }
    
    // 2. æ„é€ å…¬å¼€è¾“å…¥
    let public_inputs = vec![
        coordinator_pub_key_x,
        coordinator_pub_key_y,
        message_root,
        current_state_root,
        new_state_commitment,
        // ... å…¶ä»–å…¬å¼€è¾“å…¥
    ];
    
    // 3. éªŒè¯ Groth16 è¯æ˜
    let is_valid = verify_groth16_proof(
        proof,
        public_inputs,
        verification_key
    )?;
    
    if !is_valid {
        return Err(ContractError::ProofVerificationFailed {});
    }
    
    // 4. æ›´æ–°çŠ¶æ€æ ¹
    STATE_COMMITMENT.save(deps.storage, &new_state_commitment)?;
    
    Ok(Response::new()
        .add_attribute("action", "process_messages")
        .add_attribute("new_state_root", new_state_commitment.to_string()))
}
```

---

## ç»“æœç»Ÿè®¡ï¼ˆProcessTallyï¼‰

Operator æäº¤ç»Ÿè®¡è¯æ˜æ¥å‘å¸ƒç»“æœã€‚

### ProcessTally æ¶ˆæ¯

```rust
ExecuteMsg::ProcessTally {
    new_tally_commitment: Uint256,     // ç»Ÿè®¡ç»“æœæ‰¿è¯º
    groth16_proof: Groth16ProofType,   // Groth16 è¯æ˜
}
```

### ç»Ÿè®¡æµç¨‹

```mermaid
sequenceDiagram
    participant Coord as Coordinator
    participant AMACI as AMACI åˆçº¦
    participant Circuit as éªŒè¯å™¨
    Note over Coord: ProcessMessages å®Œæˆ
    Coord->>Coord: 1. éå†çŠ¶æ€æ ‘
    Coord->>Coord: 2. ç»Ÿè®¡æ¯ä¸ªé€‰é¡¹çš„ç¥¨æ•°
    Coord->>Coord: 3. ç”Ÿæˆ Tally è¯æ˜
    Coord->>AMACI: 4. ProcessTally(tally, proof)
    AMACI->>Circuit: 5. éªŒè¯è¯æ˜
    alt è¯æ˜æ— æ•ˆ
        Circuit-->>AMACI: éªŒè¯å¤±è´¥
        AMACI-->>Coord: é”™è¯¯ï¼šè¯æ˜æ— æ•ˆ
    end
    Circuit-->>AMACI: éªŒè¯æˆåŠŸ
    AMACI->>AMACI: 6. ä¿å­˜ç»Ÿè®¡ç»“æœ
    AMACI->>AMACI: 7. æ›´æ–°è½®æ¬¡çŠ¶æ€ä¸º Tallied
    AMACI-->>Coord: æˆåŠŸ
    Note over AMACI: ç»“æœå·²å…¬å¼€
```

### ç»“æœå‘å¸ƒ

```rust
fn process_tally(
    deps: DepsMut,
    new_tally_commitment: Uint256,
    proof: Groth16ProofType
) -> Result<Response, ContractError> {
    // 1. éªŒè¯è¯æ˜
    let is_valid = verify_groth16_proof(
        proof,
        public_inputs,
        tally_verification_key
    )?;
    
    if !is_valid {
        return Err(ContractError::ProofVerificationFailed {});
    }
    
    // 2. ä¿å­˜ç»Ÿè®¡ç»“æœ
    TALLY_COMMITMENT.save(deps.storage, &new_tally_commitment)?;
    
    // 3. æ›´æ–°çŠ¶æ€
    let mut round_info = ROUND_INFO.load(deps.storage)?;
    round_info.status = RoundStatus::Tallied;
    ROUND_INFO.save(deps.storage, &round_info)?;
    
    Ok(Response::new()
        .add_attribute("action", "process_tally")
        .add_attribute("tally_commitment", new_tally_commitment.to_string()))
}
```

## æŸ¥è¯¢åŠŸèƒ½

### è½®æ¬¡ä¿¡æ¯

```rust
QueryMsg::GetRoundInfo {}
```

è¿”å›ï¼š

```rust
pub struct RoundInfoResponse {
    pub round_info: RoundInfo,
    pub status: RoundStatus,
    pub coordinator_pubkey: PubKey,
    pub num_signups: u64,
    pub max_voters: Uint256,
    // ... å…¶ä»–ä¿¡æ¯
}
```

### æ¶ˆæ¯æŸ¥è¯¢

```rust
// è·å–å•æ¡æ¶ˆæ¯
QueryMsg::GetMessage { index: u64 }

// è·å–æ‰€æœ‰æ¶ˆæ¯
QueryMsg::GetMessages {}

// è·å–æ¶ˆæ¯æ•°é‡
QueryMsg::GetNumMessages {}
```

### çŠ¶æ€æŸ¥è¯¢

```rust
// è·å–çŠ¶æ€æ ¹
QueryMsg::GetStateRoot {}

// è·å–ç»Ÿè®¡ç»“æœ
QueryMsg::GetTallyResult {}

// è·å–ç­¾åˆ°æ•°é‡
QueryMsg::GetNumSignups {}
```

## åŒ¿åæ€§å¢å¼º

### å»æ´»åŒ–æ£€æµ‹

AMACI æ”¯æŒå»æ´»åŒ–æ£€æµ‹æ¥å¢å¼ºåŒ¿åæ€§ï¼š

```rust
// åˆå§‹åŒ–æ—¶é…ç½®
pre_deactivate_root: Uint256,  // å»æ´»åŒ– Merkle æ ¹
pre_deactivate_coordinator: Option<PubKey>,  // å»æ´»åŒ–åè°ƒè€…
```

### å·¥ä½œåŸç†

```mermaid
graph TD
    A[ç”¨æˆ·å…¬é’¥] --> B{åœ¨å»æ´»åŒ–æ ‘ä¸­?}
    B -->|æ˜¯| C[æ ‡è®°ä¸ºå»æ´»åŒ–]
    B -->|å¦| D[æ­£å¸¸å¤„ç†]
    C --> E[ç‰¹æ®Šå¤„ç†æˆ–æ’é™¤]
    D --> F[æ­£å¸¸ç»Ÿè®¡æŠ•ç¥¨]
```

## è½®æ¬¡çŠ¶æ€

AMACI åˆçº¦æœ‰ä»¥ä¸‹çŠ¶æ€ï¼š

```rust
pub enum RoundStatus {
    Created = 0,      // å·²åˆ›å»º
    Voting = 1,       // æŠ•ç¥¨ä¸­
    Processing = 2,   // å¤„ç†ä¸­
    Tallied = 3,      // å·²ç»Ÿè®¡
}
```

### çŠ¶æ€è½¬æ¢

```mermaid
stateDiagram-v2
    [*] --> Created: åˆçº¦å®ä¾‹åŒ–
    Created --> Voting: åˆ°è¾¾å¼€å§‹æ—¶é—´
    Voting --> Processing: æŠ•ç¥¨æœŸç»“æŸ
    Processing --> Processing: ProcessMessages å¤šæ¬¡è°ƒç”¨
    Processing --> Tallied: ProcessTally æˆåŠŸ
    Tallied --> [*]: è½®æ¬¡ç»“æŸ
```

## å®‰å…¨ç‰¹æ€§

### æ—¶é—´éªŒè¯

```rust
fn ensure_voting_period(
    env: &Env,
    voting_time: &VotingTime
) -> Result<(), ContractError> {
    let current_time = env.block.time.seconds();
    
    if current_time < voting_time.start_time {
        return Err(ContractError::VotingNotStarted {});
    }
    
    if current_time > voting_time.end_time {
        return Err(ContractError::VotingEnded {});
    }
    
    Ok(())
}
```

### æƒé™æ§åˆ¶

```rust
// åªæœ‰ Coordinator å¯ä»¥å¤„ç†æ¶ˆæ¯
fn ensure_coordinator(
    sender: &Addr,
    coordinator: &Addr
) -> Result<(), ContractError> {
    if sender != coordinator {
        return Err(ContractError::Unauthorized {});
    }
    Ok(())
}
```

### é‡å…¥ä¿æŠ¤

```rust
// ä½¿ç”¨çŠ¶æ€é”é˜²æ­¢é‡å…¥
fn process_messages_with_lock(
    deps: DepsMut,
    // ... å‚æ•°
) -> Result<Response, ContractError> {
    // æ£€æŸ¥é”
    let is_locked = PROCESSING_LOCK.may_load(deps.storage)?.unwrap_or(false);
    if is_locked {
        return Err(ContractError::AlreadyProcessing {});
    }
    
    // è®¾ç½®é”
    PROCESSING_LOCK.save(deps.storage, &true)?;
    
    // å¤„ç†é€»è¾‘
    let result = process_messages_internal(deps, ...);
    
    // é‡Šæ”¾é”
    PROCESSING_LOCK.save(deps.storage, &false)?;
    
    result
}
```

## æ³¨å†Œæ–¹å¼é€‰æ‹©å»ºè®®

æ ¹æ®ä½ çš„éšç§éœ€æ±‚é€‰æ‹©åˆé€‚çš„æ³¨å†Œæ–¹å¼ï¼š

### ä½éšç§åœºæ™¯

**ä½¿ç”¨ Signupï¼š**
- ç¤¾åŒºå†…éƒ¨æŠ•ç¥¨
- éæ•æ„Ÿå†³ç­–
- å¯ä¿¡çš„ Operator

### é«˜éšç§åœºæ™¯

**ä½¿ç”¨ Add-new-keyï¼š**
- å¤§é¢èµ„é‡‘åˆ†é…
- æ•æ„Ÿè¯é¢˜æŠ•ç¥¨
- å¯èƒ½å¼•èµ·äº‰è®®çš„å†³ç­–
- ä¸å®Œå…¨ä¿¡ä»» Operator

**ä½¿ç”¨ Pre-add-new-keyï¼š**
- éœ€è¦å¿«é€ŸåŒ¿å
- Round å·²é¢„é…ç½®
- ç´§æ€¥æŠ•ç¥¨åœºæ™¯

### æ··åˆä½¿ç”¨

åœ¨åŒä¸€ä¸ª Round ä¸­ï¼Œä¸åŒç”¨æˆ·å¯ä»¥ä½¿ç”¨ä¸åŒçš„æ³¨å†Œæ–¹å¼ï¼š

```typescript
// ç”¨æˆ· A: ä½¿ç”¨ signupï¼ˆå¿«é€Ÿï¼‰
await userA.signup({...});

// ç”¨æˆ· B: ä½¿ç”¨ add-new-keyï¼ˆåŒ¿åï¼‰
await userB.addNewKey({...});

// ç”¨æˆ· C: ä½¿ç”¨ pre-add-new-keyï¼ˆå¿«é€ŸåŒ¿åï¼‰
await userC.rawPreAddNewKey({...});

// éƒ½å¯ä»¥æ­£å¸¸æŠ•ç¥¨
await userA.vote({...});
await userB.vote({...});
await userC.vote({...});
```

## ä¸‹ä¸€æ­¥

å®Œæˆåï¼Œæ‚¨å¯ä»¥äº†è§£äº† AMACI åˆçº¦çš„æ‰€æœ‰æ³¨å†Œæ–¹å¼ï¼Œæ¥ä¸‹æ¥å¯ä»¥ï¼š

- [AMACI éšç§æœºåˆ¶](/docs/protocol/amaci-privacy) - æ·±å…¥ç†è§£èº«ä»½åŒ¿ååŒ–åŸç†
- ğŸ”„ [å®Œæ•´å·¥ä½œæµç¨‹](/docs/contracts/workflow) - ç†è§£ä»åˆ›å»ºåˆ°ç»“æœçš„å…¨æµç¨‹
- ğŸ’» [SDK ä½¿ç”¨æŒ‡å—](/docs/sdk/voting-guide) - ä½¿ç”¨ SDK ä¸ AMACI äº¤äº’
- [ç¤ºä¾‹ä»£ç ](/docs/examples/basic-voting) - æŸ¥çœ‹å®Œæ•´çš„æŠ•ç¥¨ç¤ºä¾‹
